#include <Arduino.h>
#include <FastAccelStepper.h>
#include <Bounce2.h>
#include <WiFi.h>        // Added for WiFi
#include <ArduinoOTA.h>  // Added for OTA
#include <WebServer.h>   // Added for HTTP Server
#include <WebSocketsServer.h> // Added for WebSocket Server
#include <ESP32Servo.h>     // Added for Servos
#include <ArduinoJson.h> // Added for JSON handling
#include "GeneralSettings_PinDef.h" // Updated include
#include "../PickPlace/PickPlace.h" // Include the new PnP header
#include <Preferences.h> // Added for Preferences
#include "../Painting/Painting.h" // Include the new Painting header
#include "html_content.h" // Include the new HTML header

// Define WiFi credentials (required by settings.h)
const char* ssid = "Everwood";
const char* password = "Everwood-Staff";
const char* hostname = "ESP32-PaintMachine"; // Example hostname

// WebSocket constants
const uint8_t ALL_CLIENTS = 255; // Broadcast to all clients

// Stepper Engine
FastAccelStepperEngine engine = FastAccelStepperEngine();

// Stepper Motors
FastAccelStepper *stepper_x = NULL;
FastAccelStepper *stepper_y_left = NULL;
FastAccelStepper *stepper_y_right = NULL;
FastAccelStepper *stepper_z = NULL;
FastAccelStepper *stepper_rot = NULL; // Added Rotation Stepper
// Note: Rotation stepper is defined in settings.h but not used here as it lacks a home switch.

// Limit Switch Debouncers
Bounce debouncer_x_home = Bounce();
Bounce debouncer_y_left_home = Bounce();
Bounce debouncer_y_right_home = Bounce();
Bounce debouncer_z_home = Bounce();
Bounce debouncer_pnp_cycle_button = Bounce(); // Added for physical button

// Servos
Servo servo_pitch;
Servo servo_roll;

// Web Server and WebSocket Server
WebServer webServer(80);
WebSocketsServer webSocket = WebSocketsServer(81);

// Preferences object
Preferences preferences;

// State Variables
bool allHomed = false; // Tracks if initial homing completed successfully
volatile bool isMoving = false; // Tracks if a move command is active
volatile bool isHoming = false; // Tracks if homing sequence is active
volatile bool inPickPlaceMode = false; // Tracks if PnP sequence is active
volatile bool pendingHomingAfterPnP = false; // Flag to home after exiting PnP
volatile bool inCalibrationMode = false; // Tracks if calibration mode is active

// NEW: Tray Dimension Variables
float trayWidth_inch = 24.0; // Default tray width
float trayHeight_inch = 18.0; // Default tray height

// Pattern/General Speed/Accel Variables (declared extern in GeneralSettings_PinDef.h)
float patternXSpeed = 20000.0; // Actual value
float patternXAccel = 20000.0; // Actual value
float patternYSpeed = 20000.0; // Actual value
float patternYAccel = 20000.0; // Actual value
float patternZSpeed = 500.0;
float patternZAccel = 1300.0;
float patternRotSpeed = 2000.0; // Reduced from 3000 for more reliable movement
float patternRotAccel = 1000.0; // Reduced from 2000 for more reliable movement

// PnP variables (declared extern in PickPlace.h, defined in PickPlace.cpp)
// Commented out here because they are defined and managed in PickPlace.cpp
/*
float pnpOffsetX_inch = 15.0;
float pnpOffsetY_inch = 0.0;
float placeFirstXAbsolute_inch = 20.0;
float placeFirstYAbsolute_inch = 20.0;
*/
// PnP Grid/Spacing Variables
int placeGridCols = 4;        // Default Columns
int placeGridRows = 5;        // Default Rows
float placeGapX_inch = 0.0f; // Calculated X GAP between items (formerly placeSpacingX_inch)
float placeGapY_inch = 0.0f; // Calculated Y GAP between items (formerly placeSpacingY_inch)

// Painting Offsets (declared extern in Painting.h, defined in Painting.cpp)
/*
float paintPatternOffsetX_inch = 0.0f;
float paintPatternOffsetY_inch = 0.0f;
float paintGunOffsetX_inch = 0.0f;   // Offset of nozzle from TCP X
float paintGunOffsetY_inch = 1.5f;   // Offset of nozzle from TCP Y (e.g., 1.5 inches forward)

// Painting Side Settings (Arrays for 4 sides: 0=Back, 1=Right, 2=Front, 3=Left)
float paintZHeight_inch[4] = { 1.0f, 1.0f, 1.0f, 1.0f }; // Default Z height for painting each side
int   paintPitchAngle[4]   = { PITCH_SERVO_MIN, PITCH_SERVO_MIN, PITCH_SERVO_MIN, PITCH_SERVO_MIN }; // Default Pitch angle
int   paintRollAngle[4]    = { ROLL_VERTICAL, ROLL_VERTICAL, ROLL_VERTICAL, ROLL_VERTICAL }; // Default Roll angle
float paintSpeed[4]        = { 10000.0f, 10000.0f, 10000.0f, 10000.0f }; // Default painting speed (steps/sec)

// Rotation Positions (degrees relative to Back=0)
// Assuming 0 = Back, 90 = Right, 180 = Front, 270 = Left
const int ROT_POS_BACK_DEG = 0;
const int ROT_POS_RIGHT_DEG = 90;
const int ROT_POS_FRONT_DEG = 180;
const int ROT_POS_LEFT_DEG = 270;
*/

// Homing states
bool x_homed = false;
bool y_left_homed = false;
bool y_right_homed = false;
bool z_homed = false;

// Function forward declarations
void homeAllAxes();
void moveToPositionInches(float targetX_inch, float targetY_inch, float targetZ_inch);
void moveToXYPositionInches(float targetX_inch, float targetY_inch);
void executePickPlaceCycle(); // Might be obsolete
void executeNextPickPlaceStep();
void enterPickPlaceMode();
void exitPickPlaceMode();
void calculateAndSetGridSpacing(int cols, int rows); // Added forward declaration here
void webSocketEvent(uint8_t num, WStype_t type, uint8_t * payload, size_t length);
void sendCurrentPositionUpdate(); // Forward declaration for position updates
void sendAllSettingsUpdate(uint8_t specificClientNum, String message); // Helper to send all settings

// Painting functions (Placeholders moved to Painting.cpp)
/*
void startPaintingSequence();
void paintSide(int sideIndex);
*/

// Function to home a single axis (modified slightly for reuse)
// Returns true if homing was successful, false otherwise (timeout or error)
bool homeSingleAxis(FastAccelStepper* stepper, Bounce* debouncer, int home_switch_pin, const char* axis_name) {
    if (!stepper) return false; // Skip if stepper not initialized

    // Serial.print("Homing ");
    // Serial.print(axis_name);
    // Serial.println("...");

    // Ensure switch pin is configured
    pinMode(home_switch_pin, INPUT);
    debouncer->attach(home_switch_pin);
    debouncer->interval(DEBOUNCE_INTERVAL);

    // Set homing speed and acceleration
    stepper->setSpeedInHz(HOMING_SPEED);
    stepper->setAcceleration(HOMING_ACCEL);

    // Start moving towards the home switch (assuming negative direction)
    stepper->runBackward();

    unsigned long startTime = millis();
    bool success = false;

    // Wait for the switch to be triggered or timeout
    while (millis() - startTime <= HOMING_TIMEOUT) {
        debouncer->update();
        webSocket.loop(); // Keep WebSocket responsive during blocking operations

        // Check if the switch is activated (read HIGH directly)
        if (debouncer->read() == HIGH) {
            // Serial.print(axis_name);
            // Serial.println(" switch triggered.");
            stepper->stopMove(); // Stop the motor smoothly first
            stepper->forceStop(); // Ensure it's stopped
            stepper->setCurrentPosition(0); // Set current position as 0
            success = true;
            // Serial.print(axis_name);
            // Serial.println(" homed.");
            break; // Exit the while loop
        }
        yield(); // Allow background tasks
    }

    if (!success) {
        stepper->forceStop(); // Ensure motor is stopped on timeout
        // Serial.print(axis_name);
        // Serial.println(" homing timed out or failed!");
    }
    return success;
}

// Function to home all axes (Kept in main.cpp as it's a core function)
void homeAllAxes() {
    // --- Exit Calibration if Active ---
    if (inCalibrationMode) {
        Serial.println("[DEBUG] homeAllAxes: Exiting calibration mode implicitly."); // DEBUG
        inCalibrationMode = false;
        // Send status update immediately? Or let Homing status override?
        // Let Homing status handle the UI update. 
    }
    // --- Original Checks ---
    // if (inCalibrationMode) { // This check is now redundant
    //     webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Exit calibration mode before homing.\"}");
    //     return;
    // }
    if (isMoving || isHoming) {
        webSocket.broadcastTXT("{\"status\":\"Busy\", \"message\":\"Machine is already moving or homing.\"}");
        return;
    }
    // Reset pick/place mode if we are homing
    inPickPlaceMode = false;

    isHoming = true;
    webSocket.broadcastTXT("{\"status\":\"Homing\", \"message\":\"Homing all axes simultaneously...\"}");
    // Serial.println("Starting Full Homing Sequence (all axes simultaneously)...");

    // Reset homed flags
    x_homed = false;
    y_left_homed = false;
    y_right_homed = false;
    z_homed = false;
    allHomed = false;

    // Initialize done flags
    bool x_done = false;
    bool y_left_done = false;
    bool y_right_done = false;
    bool z_done = false;

    // Configure and start all steppers if they exist
    // Z Axis
    if (stepper_z) {
        pinMode(Z_HOME_SWITCH, INPUT);
        debouncer_z_home.attach(Z_HOME_SWITCH);
        debouncer_z_home.interval(DEBOUNCE_INTERVAL);
        stepper_z->setSpeedInHz(HOMING_SPEED);
        stepper_z->setAcceleration(HOMING_ACCEL);
        stepper_z->runBackward();
    } else {
        z_done = true; // Consider done if stepper doesn't exist
    }

    // X Axis
    if (stepper_x) {
        pinMode(X_HOME_SWITCH, INPUT);
        debouncer_x_home.attach(X_HOME_SWITCH);
        debouncer_x_home.interval(DEBOUNCE_INTERVAL);
        stepper_x->setSpeedInHz(HOMING_SPEED);
        stepper_x->setAcceleration(HOMING_ACCEL);
        stepper_x->runBackward();
    } else {
        x_done = true; // Consider done if stepper doesn't exist
    }

    // Y Left Axis
    if (stepper_y_left) {
        pinMode(Y_LEFT_HOME_SWITCH, INPUT);
        debouncer_y_left_home.attach(Y_LEFT_HOME_SWITCH);
        debouncer_y_left_home.interval(DEBOUNCE_INTERVAL);
        stepper_y_left->setSpeedInHz(HOMING_SPEED);
        stepper_y_left->setAcceleration(HOMING_ACCEL);
        stepper_y_left->runBackward();
    } else {
        y_left_done = true; // Consider done if stepper doesn't exist
    }

    // Y Right Axis
    if (stepper_y_right) {
        pinMode(Y_RIGHT_HOME_SWITCH, INPUT);
        debouncer_y_right_home.attach(Y_RIGHT_HOME_SWITCH);
        debouncer_y_right_home.interval(DEBOUNCE_INTERVAL);
        stepper_y_right->setSpeedInHz(HOMING_SPEED);
        stepper_y_right->setAcceleration(HOMING_ACCEL);
        stepper_y_right->runBackward();
    } else {
        y_right_done = true; // Consider done if stepper doesn't exist
    }

    // Wait for all axes to home or timeout
    unsigned long startTime = millis();
    
    // Monitor all switches and stop once triggered
    while (!(x_done && y_left_done && y_right_done && z_done)) {
        if (millis() - startTime > HOMING_TIMEOUT) {
            // Serial.println("Homing timed out!");
            // Stop all motors that haven't homed yet
            if (stepper_x && !x_done) stepper_x->forceStop();
            if (stepper_y_left && !y_left_done) stepper_y_left->forceStop();
            if (stepper_y_right && !y_right_done) stepper_y_right->forceStop();
            if (stepper_z && !z_done) stepper_z->forceStop();
            
            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Homing timed out!\"}");
            isHoming = false;
            return;
        }

        webSocket.loop(); // Keep WebSocket responsive

        // Check Z axis
        if (stepper_z && !z_done) {
            debouncer_z_home.update();
            if (debouncer_z_home.read() == HIGH) {
                stepper_z->stopMove();
                stepper_z->forceStop();
                stepper_z->setCurrentPosition(0);
                z_done = true;
                z_homed = true;
                // Serial.println("Z axis homed.");
            }
        }

        // Check X axis
        if (stepper_x && !x_done) {
            debouncer_x_home.update();
            if (debouncer_x_home.read() == HIGH) {
                stepper_x->stopMove();
                stepper_x->forceStop();
                stepper_x->setCurrentPosition(0);
                x_done = true;
                x_homed = true;
                // Serial.println("X axis homed.");
            }
        }

        // Check Y Left axis
        if (stepper_y_left && !y_left_done) {
            debouncer_y_left_home.update();
            if (debouncer_y_left_home.read() == HIGH) {
                stepper_y_left->stopMove();
                stepper_y_left->forceStop();
                stepper_y_left->setCurrentPosition(0);
                y_left_done = true;
                y_left_homed = true;
                // Serial.println("Y Left homed.");
            }
        }

        // Check Y Right axis
        if (stepper_y_right && !y_right_done) {
            debouncer_y_right_home.update();
            if (debouncer_y_right_home.read() == HIGH) {
                stepper_y_right->stopMove();
                stepper_y_right->forceStop();
                stepper_y_right->setCurrentPosition(0);
                y_right_done = true;
                y_right_homed = true;
                // Serial.println("Y Right homed.");
            }
        }
        
        yield(); // Allow background tasks
    }

    // Check if all homing was successful
    bool all_success = x_homed && y_left_homed && y_right_homed && z_homed;

    if (all_success) {
        // Serial.println("All axes homed successfully.");
        
        // Add a small delay to allow motor states to settle before move-away
        delay(50); // 50 millisecond delay

        // Move X and Y away from the home position slightly
        webSocket.broadcastTXT("{\"status\":\"Homing\", \"message\":\"Moving away from home switches...\"}");
        long target_steps = (long)(0.5 * STEPS_PER_INCH_XY); // 0.5 inches in steps
        
        if (stepper_x) {
            stepper_x->setSpeedInHz(patternXSpeed); // Use general pattern speed
            stepper_x->setAcceleration(patternXAccel / 5.0); // Use HALF pattern acceleration
            stepper_x->moveTo(target_steps);
        }
        if (stepper_y_left) {
            stepper_y_left->setSpeedInHz(patternYSpeed);
            stepper_y_left->setAcceleration(patternYAccel / 5.0); // Use HALF pattern acceleration
            stepper_y_left->moveTo(target_steps);
        }
        if (stepper_y_right) {
            stepper_y_right->setSpeedInHz(patternYSpeed);
            stepper_y_right->setAcceleration(patternYAccel / 5.0); // Use HALF pattern acceleration
            stepper_y_right->moveTo(target_steps);
        }
        
        // DIAGNOSTIC: Print positions BEFORE move-away
        Serial.printf("*** Positions before move-away: X=%ld, YL=%ld, YR=%ld ***\n", 
                      (stepper_x ? stepper_x->getCurrentPosition() : -1),
                      (stepper_y_left ? stepper_y_left->getCurrentPosition() : -1),
                      (stepper_y_right ? stepper_y_right->getCurrentPosition() : -1));

        // Wait for the move-away to complete
        // Serial.println("Waiting for move away from home...");
        while ((stepper_x && stepper_x->isRunning()) || 
               (stepper_y_left && stepper_y_left->isRunning()) || 
               (stepper_y_right && stepper_y_right->isRunning())) {
            webSocket.loop(); // Keep responsive
            yield();
        }
        // Serial.println("Move away complete.");
        
        allHomed = true;
        webSocket.broadcastTXT("{\"status\":\"Ready\", \"message\":\"All axes homed successfully.\"}");
    } else {
        // Serial.println("ERROR: Homing Failed!");
        String failedAxes = "";
        if (!x_homed) failedAxes += "X ";
        if (!y_left_homed) failedAxes += "Y-Left ";
        if (!y_right_homed) failedAxes += "Y-Right ";
        if (!z_homed) failedAxes += "Z";
        webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Homing Failed for: " + failedAxes + "\"}");
        allHomed = false;
    }

    isHoming = false;
}

// --- Movement Logic ---
void moveToPositionInches(float targetX_inch, float targetY_inch, float targetZ_inch) {
    if (inCalibrationMode) {
         webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Cannot perform general move while in Calibration mode.\"}");
         return;
    }
    if (!allHomed) {
        // Serial.println("Error: Machine not homed. Please home first.");
        webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Machine not homed. Please home first.\"}");
        return;
    }
    if (isMoving || isHoming) {
         // Serial.println("Error: Machine is busy.");
         webSocket.broadcastTXT("{\"status\":\"Busy\", \"message\":\"Machine is already moving or homing.\"}");
         return;
    }
    if (inPickPlaceMode) {
        // Disallow general moves while in PnP mode (specific PnP moves should be handled separately)
        webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Cannot perform general move while in Pick/Place mode.\"}");
        return;
    }

    isMoving = true;
    // Serial.printf("Moving to X:%.2f, Y:%.2f, Z:%.2f inches\\n", targetX_inch, targetY_inch, targetZ_inch);
    String msg = "{\"status\":\"Moving\", \"message\":\"Moving to X:" + String(targetX_inch, 2) +
                 ", Y:" + String(targetY_inch, 2) + ", Z:" + String(targetZ_inch, 2) + "\"}";
    webSocket.broadcastTXT(msg);


    // Convert inches to steps
    long targetX_steps = (long)(targetX_inch * STEPS_PER_INCH_XY);
    long targetY_steps = (long)(targetY_inch * STEPS_PER_INCH_XY);
    long targetZ_steps = (long)(targetZ_inch * STEPS_PER_INCH_Z);

    // === Z Limit Check ===
    long min_z_steps = (long)(Z_MAX_TRAVEL_NEG_INCH * STEPS_PER_INCH_Z);
    long max_z_steps = (long)(Z_HOME_POS_INCH * STEPS_PER_INCH_Z); // Should be 0
    targetZ_steps = max(min_z_steps, targetZ_steps); // Ensure not below min travel
    targetZ_steps = min(max_z_steps, targetZ_steps); // Ensure not above home position (0)
    // === End Z Limit Check ===

    // Move Z axis first (if necessary)
    bool needToMoveZ = (stepper_z && stepper_z->getCurrentPosition() != targetZ_steps);
    if (needToMoveZ) {
        stepper_z->setSpeedInHz(patternZSpeed);
        stepper_z->setAcceleration(patternZAccel);
        stepper_z->moveTo(targetZ_steps);
        // Serial.printf("  Moving Z to %ld steps\\n", targetZ_steps);
    }

    // Wait for Z to finish if it moved
    while (needToMoveZ && stepper_z->isRunning()) {
        webSocket.loop(); // Keep websocket alive
        yield();
    }
    // Serial.println("  Z move complete (or skipped).");


    // Move X and Y axes simultaneously
    bool needToMoveX = (stepper_x && stepper_x->getCurrentPosition() != targetX_steps);
    bool needToMoveY = (stepper_y_left && stepper_y_left->getCurrentPosition() != targetY_steps) ||
                       (stepper_y_right && stepper_y_right->getCurrentPosition() != targetY_steps);

    if (needToMoveX) {
        stepper_x->setSpeedInHz(patternXSpeed);
        stepper_x->setAcceleration(patternXAccel);
        stepper_x->moveTo(targetX_steps);
        // Serial.printf("  Moving X to %ld steps\\n", targetX_steps);
    }
    if (needToMoveY) {
        if (stepper_y_left) {
             stepper_y_left->setSpeedInHz(patternYSpeed);
             stepper_y_left->setAcceleration(patternYAccel);
             stepper_y_left->moveTo(targetY_steps);
             // Serial.printf("  Moving Y Left to %ld steps\\n", targetY_steps);
        }
       if (stepper_y_right) {
             stepper_y_right->setSpeedInHz(patternYSpeed);
             stepper_y_right->setAcceleration(patternYAccel);
             stepper_y_right->moveTo(targetY_steps);
             // Serial.printf("  Moving Y Right to %ld steps\\n", targetY_steps);
       }
    }

    // Wait for X and Y to complete (this part is checked in the main loop now)
}

// Function to move only X and Y axes to a target position in inches
// Assumes Z is already at the desired height
// IMPORTANT: This is for GENERAL moves, not PnP moves.
// PnP moves use moveToXYPositionInches_PnP() in PickPlace.cpp
void moveToXYPositionInches(float targetX_inch, float targetY_inch) {
    // Check if steppers exist
    if (!stepper_x || !stepper_y_left || !stepper_y_right) {
        // Serial.println("ERROR: Cannot move XY - Steppers not initialized.");
        webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"XY Steppers not initialized.\"}");
        return;
    }

    // Convert inches to steps
    long targetX_steps = (long)(targetX_inch * STEPS_PER_INCH_XY);
    long targetY_steps = (long)(targetY_inch * STEPS_PER_INCH_XY);

    // Check if already at target
    bool x_at_target = (stepper_x->getCurrentPosition() == targetX_steps);
    bool y_at_target = (stepper_y_left->getCurrentPosition() == targetY_steps) && (stepper_y_right->getCurrentPosition() == targetY_steps);

    if (x_at_target && y_at_target) {
        // Serial.println("Already at target XY position.");
        return; // No move needed
    }

    // Set speeds and accelerations
    if (!x_at_target) {
        stepper_x->setSpeedInHz(patternXSpeed);
        stepper_x->setAcceleration(patternXAccel);
        stepper_x->moveTo(targetX_steps);
    }
    if (!y_at_target) {
        stepper_y_left->setSpeedInHz(patternYSpeed);
        stepper_y_left->setAcceleration(patternYAccel);
        stepper_y_left->moveTo(targetY_steps);

        stepper_y_right->setSpeedInHz(patternYSpeed);
        stepper_y_right->setAcceleration(patternYAccel);
        stepper_y_right->moveTo(targetY_steps);
    }
    // The isMoving flag should be set by the caller, and completion detected in loop()
}


// --- Movement Helpers for Painting ---

// Moves only the Z axis to the target position in inches, waits for completion
void moveZToPositionInches(float targetZ_inch, float speedHz, float accel) {
    // Check if machine is busy or in a conflicting mode
    if (isMoving || isHoming || inPickPlaceMode || inCalibrationMode) {
        Serial.printf("[ERROR] moveZToPositionInches denied: Machine state conflict (isMoving=%d, isHoming=%d, inPnP=%d, inCalib=%d)\n", isMoving, isHoming, inPickPlaceMode, inCalibrationMode);
        webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Cannot move Z, machine busy or in special mode.\"}");
        return;
    }

    if (!stepper_z) {
         webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Z Stepper not initialized.\"}");
         return;
    }

    long targetZ_steps = (long)(targetZ_inch * STEPS_PER_INCH_Z);
    // === Z Limit Check ===
    long min_z_steps = (long)(Z_MAX_TRAVEL_NEG_INCH * STEPS_PER_INCH_Z);
    long max_z_steps = (long)(Z_HOME_POS_INCH * STEPS_PER_INCH_Z); // Should be 0
    targetZ_steps = max(min_z_steps, targetZ_steps); // Ensure not below min travel
    targetZ_steps = min(max_z_steps, targetZ_steps); // Ensure not above home position (0)
    // === End Z Limit Check ===

    long currentZ_steps = stepper_z->getCurrentPosition();

    if (targetZ_steps == currentZ_steps) {
        // Serial.println("Z axis already at target.");
        return; // Already there
    }

    // Temporarily set moving flag for this blocking move
    isMoving = true;
    // Serial.printf("Moving Z from %.2f to %.2f inches (Steps: %ld to %ld, Speed: %.0f, Accel: %.0f)\n",
    //               (float)currentZ_steps / STEPS_PER_INCH_Z, targetZ_inch, currentZ_steps, targetZ_steps, speedHz, accel);

    stepper_z->setSpeedInHz(speedHz);
    stepper_z->setAcceleration(accel);
    stepper_z->moveTo(targetZ_steps);

    // Wait for Z move completion (blocking)
    while (stepper_z->isRunning()) {
        webSocket.loop(); // Keep websocket alive
        yield();
    }
    // Serial.println("Z move complete.");
    isMoving = false; // Clear flag after blocking move completes
}

// Moves X and Y axes to the target position using specified speed/accel for painting, waits for completion
void moveToXYPositionInches_Paint(float targetX_inch, float targetY_inch, float speedHz, float accel) {
    // No state checking here, assumes caller (paintSide) manages state
    long targetX_steps = (long)(targetX_inch * STEPS_PER_INCH_XY);
    long targetY_steps = (long)(targetY_inch * STEPS_PER_INCH_XY);

    long currentX_steps = stepper_x->getCurrentPosition();
    long currentY_steps_L = stepper_y_left->getCurrentPosition();
    long currentY_steps_R = stepper_y_right->getCurrentPosition(); // Assuming right follows left

    bool x_at_target = (currentX_steps == targetX_steps);
    bool y_at_target = (currentY_steps_L == targetY_steps); // Assume right motor follows

    if (x_at_target && y_at_target) {
        // Serial.println("Already at target paint XY.");
        return; // No move needed
    }

    // Serial.printf("Painting move XY to (%.2f, %.2f) inches (Steps: X %ld, Y %ld, Speed: %.0f, Accel: %.0f)\n",
    //               targetX_inch, targetY_inch, targetX_steps, targetY_steps, speedHz, accel);

    if (!x_at_target) {
        stepper_x->setSpeedInHz(speedHz); // Use provided speed
        stepper_x->setAcceleration(accel); // Use provided accel
        stepper_x->moveTo(targetX_steps);
    }
    if (!y_at_target) {
        // Assuming Y speed/accel are the same for painting moves
        stepper_y_left->setSpeedInHz(speedHz);
        stepper_y_left->setAcceleration(accel);
        stepper_y_left->moveTo(targetY_steps);

        stepper_y_right->setSpeedInHz(speedHz);
        stepper_y_right->setAcceleration(accel);
        stepper_y_right->moveTo(targetY_steps);
    }

    // Wait for XY move completion (blocking for simplicity in painting sequence)
    while (stepper_x->isRunning() || stepper_y_left->isRunning() || stepper_y_right->isRunning()) {
        yield();
    }
    // Serial.println("Paint XY move complete.");
}


// --- Painting Logic ---

void paintSide(int sideIndex) {
    Serial.printf("Starting paintSide for side %d\n", sideIndex);

    // 1. Check Machine State
    if (!allHomed || isMoving || isHoming || inPickPlaceMode || inCalibrationMode) {
        Serial.printf("[ERROR] paintSide denied: Invalid state (allHomed=%d, isMoving=%d, isHoming=%d, inPickPlaceMode=%d, inCalibrationMode=%d)\n",
                      allHomed, isMoving, isHoming, inPickPlaceMode, inCalibrationMode);
        webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Cannot start painting, invalid machine state.\"}");
        return;
    }

    // 2. Set Machine Busy State
    isMoving = true; // Use isMoving flag to indicate painting activity
    char busyMsg[100];
    sprintf(busyMsg, "{\"status\":\"Busy\", \"message\":\"Painting Side %d...\"}", sideIndex);
    webSocket.broadcastTXT(busyMsg);
    Serial.println(busyMsg); // Debug

    // 3. Get Side Parameters
    float zHeight = paintZHeight_inch[sideIndex];
    int pitch = paintPitchAngle[sideIndex];
    int roll = paintRollAngle[sideIndex];
    float speed = paintSpeed[sideIndex]; // Speed in steps/s
    // For now, use pattern accel, maybe add paintAccel later
    float accel = patternXAccel; // Assuming X/Y use same accel for painting

    // 4. Optional: Rotate (Example: Rotate to 0 degrees for Side 0)
    if (sideIndex == 0 && stepper_rot) {
        Serial.println("Rotating to 0 degrees for Side 0 painting...");
        long targetRotSteps = 0; // Assuming 0 steps = 0 degrees
        if (stepper_rot->getCurrentPosition() != targetRotSteps) {
            stepper_rot->setSpeedInHz(patternZSpeed); // Use a reasonable speed/accel for rotation
            stepper_rot->setAcceleration(patternZAccel);
            stepper_rot->moveTo(targetRotSteps);
            while (stepper_rot->isRunning()) {
                yield();
            }
            Serial.println("Rotation complete.");
        } else {
            Serial.println("Already at 0 degrees.");
        }
        delay(100); // Small delay after rotation
    }
     // Add logic for other sides if needed

    // 5. Set Servo Angles
    Serial.printf("Setting servos: Pitch=%d, Roll=%d\n", pitch, roll);
    servo_pitch.write(pitch);
    servo_roll.write(roll);
    delay(300); // Allow servos to settle

    // 6. Define Path Start Point (Absolute PnP Drop Off Location)
    float pathStartX = placeFirstXAbsolute_inch;
    float pathStartY = placeFirstYAbsolute_inch;
    Serial.printf("Path Start (PnP Drop Off): (%.2f, %.2f)\n", pathStartX, pathStartY);
    Serial.printf("Using Gun Offset: (%.2f, %.2f)\n", paintGunOffsetX_inch, paintGunOffsetY_inch);

    // 7. Move to Start Z Height
    Serial.println("Moving to start Z height...");
    moveZToPositionInches(zHeight, patternZSpeed, patternZAccel);

    // 8. Calculate and Move TCP to START of FIRST SWEEP (Top-Right Corner)
    float startTcpX = pathStartX + paintGunOffsetX_inch + 0.25; // Start 0.25 inches to the right
    float startTcpY = pathStartY + paintGunOffsetY_inch;
    Serial.printf("Moving TCP to start of first sweep (Top-Right): (%.2f, %.2f)\n", startTcpX, startTcpY);
    moveToXYPositionInches_Paint(startTcpX, startTcpY, speed, accel);

    // 9. Execute Painting Path (Sweep Left/Down/Sweep Right/Down...)
    Serial.println("Starting painting path...");
    float currentTcpX = startTcpX;
    float currentTcpY = startTcpY;

    // Special pattern for back side (side 0)
    if (sideIndex == 0) {
        float rowSpacing = 3.0 + placeGapY_inch; // Move down by 3 inches + y gap
        Serial.printf("Back side painting: Using row spacing of %.2f (3.0 + gap %.2f)\n", rowSpacing, placeGapY_inch);
        
        // Use roll angle to determine painting orientation
        bool isVertical = (roll == ROLL_VERTICAL);
        Serial.printf("Back side orientation: %s (roll=%d)\n", isVertical ? "VERTICAL" : "HORIZONTAL", roll);
        
        // Add gun orientation display
        int gunOrientation = paintGunOrientation[sideIndex];
        Serial.printf("Gun orientation: %s (gun_orient=%d)\n", 
                     (gunOrientation == ROLL_VERTICAL) ? "VERTICAL" : "HORIZONTAL", gunOrientation);
        
        if (isVertical) {
            // VERTICAL ORIENTATION - Sweep horizontally, move down between rows
            bool movingLeft = true; // Start by moving left (negative X)
            
            for (int r = 0; r < placeGridRows; ++r) {
                // Calculate Y position for this row
                float targetTcpY = startTcpY - (r * rowSpacing);
                
                // Move to correct Y position if needed
                if (abs(currentTcpY - targetTcpY) > 0.001) {
                    moveToXYPositionInches_Paint(currentTcpX, targetTcpY, speed, accel);
                    currentTcpY = targetTcpY;
                }
                
                // Calculate target X based on direction
                float targetTcpX;
                if (movingLeft) {
                    // Moving left (negative X direction)
                    targetTcpX = startTcpX - trayWidth_inch;
                    Serial.printf("Row %d: Sweeping Left from X=%.2f to X=%.2f at Y=%.2f\n", 
                                r, currentTcpX, targetTcpX, targetTcpY);
                } else {
                    // Moving right (positive X direction)
                    targetTcpX = startTcpX;
                    Serial.printf("Row %d: Sweeping Right from X=%.2f to X=%.2f at Y=%.2f\n", 
                                r, currentTcpX, targetTcpX, targetTcpY);
                }
                
                // Execute the sweep
                moveToXYPositionInches_Paint(targetTcpX, targetTcpY, speed, accel);
                currentTcpX = targetTcpX;
                
                // Flip direction for next row
                movingLeft = !movingLeft;
            }
        } else {
            // HORIZONTAL ORIENTATION - Sweep vertically, move right between columns
            bool movingDown = true; // Start by moving down (negative Y)
            
            for (int c = 0; c < placeGridCols; ++c) {
                // Calculate X position for this column
                float targetTcpX = startTcpX - (c * (trayWidth_inch / (placeGridCols - 1)));
                
                // Move to correct X position if needed
                if (abs(currentTcpX - targetTcpX) > 0.001) {
                    moveToXYPositionInches_Paint(targetTcpX, currentTcpY, speed, accel);
                    currentTcpX = targetTcpX;
                }
                
                // Calculate target Y based on direction
                float targetTcpY;
                if (movingDown) {
                    // Moving down (negative Y direction)
                    targetTcpY = startTcpY - (placeGridRows - 1) * rowSpacing;
                    Serial.printf("Column %d: Sweeping Down from Y=%.2f to Y=%.2f at X=%.2f\n", 
                                c, currentTcpY, targetTcpY, targetTcpX);
                } else {
                    // Moving up (positive Y direction)
                    targetTcpY = startTcpY;
                    Serial.printf("Column %d: Sweeping Up from Y=%.2f to Y=%.2f at X=%.2f\n", 
                                c, currentTcpY, targetTcpY, targetTcpX);
                }
                
                // Execute the sweep
                moveToXYPositionInches_Paint(targetTcpX, targetTcpY, speed, accel);
                currentTcpY = targetTcpY;
                
                // Flip direction for next column
                movingDown = !movingDown;
            }
        }
    } else {
        // Original pattern for other sides
    for (int r = 0; r < placeGridRows; ++r) {
        float targetTcpX;
        // Corrected Y calculation: Subtract spacing to move down
            float targetTcpY = (pathStartY - r * placeGapY_inch) + paintGunOffsetY_inch;

        // --- Determine Sweep Target X --- 
        if (r % 2 == 0) { // Even row (0, 2, ...): Sweep Left
                targetTcpX = (pathStartX - (placeGridCols - 1) * placeGapX_inch) + paintGunOffsetX_inch;
            Serial.printf("Row %d (Even): Sweeping Left to TCP X=%.2f, Y=%.2f\n", r, targetTcpX, targetTcpY);
        } else { // Odd row (1, 3, ...): Sweep Right
            targetTcpX = pathStartX + paintGunOffsetX_inch;
            Serial.printf("Row %d (Odd): Sweeping Right to TCP X=%.2f, Y=%.2f\n", r, targetTcpX, targetTcpY);
        }
        
        // --- Execute Horizontal Sweep --- 
        // Only move if Y is already correct (it should be from previous step or initial move)
        if (abs(currentTcpY - targetTcpY) < 0.001) { // Check if Y is already correct
             moveToXYPositionInches_Paint(targetTcpX, targetTcpY, speed, accel);
             currentTcpX = targetTcpX; // Update current X
        } else {
             Serial.printf("[WARN] Row %d: Y position mismatch before sweep (Current: %.3f, Target: %.3f). Skipping sweep, moving directly down.\n", r, currentTcpY, targetTcpY);
             // If Y is wrong, just move to the correct Y at the *end* X of this sweep
             moveToXYPositionInches_Paint(targetTcpX, targetTcpY, speed, accel);
             currentTcpX = targetTcpX;
             currentTcpY = targetTcpY; // Update Y as well
        }

        // --- Move Down to Next Row (if not the last row) --- 
        if (r < placeGridRows - 1) {
            // Corrected Y calculation: Subtract spacing to move down
                float nextRowTcpY = (pathStartY - (r + 1) * placeGapY_inch) + paintGunOffsetY_inch;
            Serial.printf("Row %d: Moving Down to Y=%.2f (X=%.2f)\n", r, nextRowTcpY, currentTcpX);
            // Move only Y axis - use moveZToPositionInches for XY? No, use XY function but keep X same.
            // Need a specific Y-only move or use XY with same X
            moveToXYPositionInches_Paint(currentTcpX, nextRowTcpY, speed, accel); // Move Y while keeping X constant
            currentTcpY = nextRowTcpY; // Update current Y
        }
    }
    }
    
    Serial.println("Painting path complete.");

    // 10. Move Z Axis Up (e.g., to safe height 0)
    Serial.println("Moving Z axis up to safe height (0)...");
    moveZToPositionInches(0.0, patternZSpeed, patternZAccel);

    // 11. Return to home position (X=0, Y=0, Z=0) << ADDED
    Serial.println("Returning to home position (X=0, Y=0, Z=0)...");
    // Use moveToPositionInches, which includes state checks and updates.
    // We need to temporarily clear isMoving so moveToPositionInches doesn't block itself.
    isMoving = false; 
    moveToPositionInches(0.0, 0.0, 0.0);
    // Wait for the return-to-home move to complete
    isMoving = true; // Set moving flag again for the wait loop
    while ((stepper_x && stepper_x->isRunning()) || (stepper_y_left && stepper_y_left->isRunning()) || (stepper_y_right && stepper_y_right->isRunning()) || (stepper_z && stepper_z->isRunning())) {
        webSocket.loop(); // Keep responsive
        yield();
    }
    Serial.println("Return to home complete.");

    // 12. Clear Busy State & Send Ready Message
    isMoving = false;
    char readyMsg[100];
    sprintf(readyMsg, "{\"status\":\"Ready\", \"message\":\"Painting Side %d complete. Returned to home.\"}", sideIndex);
    webSocket.broadcastTXT(readyMsg);
    Serial.println(readyMsg);

    sendCurrentPositionUpdate(); // Send final position
}

// --- Web Server and WebSocket Logic ---

void handleRoot() {
  // Serial.println("Serving root page.");
  webServer.send(200, "text/html", HTML_PROGMEM); // Use HTML_PROGMEM from html_content.h
}

void webSocketEvent(uint8_t num, WStype_t type, uint8_t * payload, size_t length) {
    switch(type) {
        case WStype_DISCONNECTED:
            Serial.printf("[%u] Disconnected!\n", num);
            break;
        case WStype_CONNECTED: {
            IPAddress ip = webSocket.remoteIP(num);
            Serial.printf("[%u] Connected from %d.%d.%d.%d url: %s\n", num, ip[0], ip[1], ip[2], ip[3], payload);
            // Send initial status and all settings using the helper function
            String welcomeMsg = "Welcome! Connected to Paint + PnP Machine.";
            sendAllSettingsUpdate(num, welcomeMsg);
            
            // Also send initial position update immediately after settings if homed
            if (allHomed) {
                 sendCurrentPositionUpdate();
             }
            }
            break;
        case WStype_TEXT:
            // Serial.printf("[%u] get Text: %s\n", num, payload); // Reduced verbosity
            if (length > 0) {
                String command = String((char*)payload);
                Serial.printf("[DEBUG] WebSocket [%u] Received Command: %s\n", num, command.c_str()); // DEBUG
                
                // --- STOP Command Handler --- << ADDED
                if (command == "STOP") {
                    Serial.println("WebSocket: Received STOP command.");
                    // Force stop all motors immediately
                    if(stepper_x) stepper_x->forceStop();
                    if(stepper_y_left) stepper_y_left->forceStop();
                    if(stepper_y_right) stepper_y_right->forceStop();
                    if(stepper_z) stepper_z->forceStop();
                    if(stepper_rot) stepper_rot->forceStop();
                    
                    // Reset state flags
                    isMoving = false;
                    isHoming = false;
                    if (inPickPlaceMode) exitPickPlaceMode(false); // Exit PnP without homing request
                    inCalibrationMode = false;
                    pendingHomingAfterPnP = false;
                    
                    // Send update
                    webSocket.broadcastTXT("{\"status\":\"Ready\", \"message\":\"STOPPED by user command.\"}");
                    sendCurrentPositionUpdate(); // Send final position after stop
                }
                // --- End STOP Command Handler ---
                
                else if (command == "HOME") { // Changed to else if
                    Serial.println("WebSocket: Received HOME command.");
                    if (isMoving || isHoming) {
                        webSocket.sendTXT(num, "{\"status\":\"Busy\",\"message\":\"Cannot home, machine is busy.\"}");
                    } else {
                        // REMOVED block that checked inPickPlaceMode here.
                        // homeAllAxes() function will handle resetting PnP/Calibration modes internally.
                        Serial.println("[DEBUG] HOME command received while idle. Calling homeAllAxes()."); // Added log
                        homeAllAxes(); // Start homing (this function sends its own status updates and resets modes)
                    }
                } else if (command == "GOTO_5_5_0") {
                    Serial.println("WebSocket: Received GOTO_5_5_0 command.");
                    moveToPositionInches(5.0, 5.0, 0.0); // This function now sends its own status updates
                } else if (command == "GOTO_20_20_0") {
                    Serial.println("WebSocket: Received GOTO_20_20_0 command.");
                    moveToPositionInches(20.0, 20.0, 0.0); // This function now sends its own status updates
                } else if (command == "ENTER_PICKPLACE") {
                     Serial.println("WebSocket: Received ENTER_PICKPLACE command.");
                     if (!allHomed) {
                         Serial.println("[DEBUG] ENTER_PICKPLACE denied: Not homed."); // DEBUG
                         // Fixed quotes
                         webSocket.sendTXT(num, "{\"status\":\"Error\",\"message\":\"Machine not homed.\"}");
                     } else if (isMoving || isHoming) {
                         Serial.println("[DEBUG] ENTER_PICKPLACE denied: Busy."); // DEBUG
                         // Fixed quotes
                         webSocket.sendTXT(num, "{\"status\":\"Busy\",\"message\":\"Machine is busy.\"}");
                     } else if (inPickPlaceMode) {
                         Serial.println("[DEBUG] ENTER_PICKPLACE denied: Already in PnP mode."); // DEBUG
                         // Exit command should be used instead
                         webSocket.sendTXT(num, "{\"status\":\"PickPlaceReady\", \"message\":\"Already in Pick/Place mode. Use Exit button.\"}");
                     } else if (inCalibrationMode) {
                         Serial.println("[DEBUG] ENTER_PICKPLACE denied: In Calibration mode."); // DEBUG
                         webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Exit calibration before entering PnP mode.\"}");
                     } else {
                         // Call the function defined in PickPlace.h
                         enterPickPlaceMode();
                     }
                 } else if (command == "EXIT_PICKPLACE") {
                     Serial.println("WebSocket: Received EXIT_PICKPLACE command.");
                     exitPickPlaceMode(true); // Call function from PickPlace.h, REQUEST homing after exit
                 } else if (command == "PNP_NEXT_STEP") { // Renamed command
                    Serial.println("WebSocket: Received PNP_NEXT_STEP command.");
                    executeNextPickPlaceStep(); // Call function from PickPlace.h
                 } else if (command == "PNP_SKIP_LOCATION") { // ADDED
                    Serial.println("WebSocket: Received PNP_SKIP_LOCATION command.");
                    skipPickPlaceLocation(); // Call function from PickPlace.h
                 } else if (command == "PNP_BACK_LOCATION") { // ADDED
                    Serial.println("WebSocket: Received PNP_BACK_LOCATION command.");
                    goBackPickPlaceLocation(); // Call function from PickPlace.h
                 } else if (command.startsWith("SET_PNP_OFFSET ")) {
                     Serial.println("WebSocket: Received SET_PNP_OFFSET command.");
                     if (isMoving || isHoming || inPickPlaceMode) {
                         Serial.println("[DEBUG] SET_PNP_OFFSET denied: Machine busy or in PnP mode.");
                         webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Cannot set offset while machine is busy or in PnP mode.\"}");
                     } else {
                         float newX, newY;
                         // Use C-style string for sscanf
                         int parsed = sscanf(command.c_str() + strlen("SET_PNP_OFFSET "), "%f %f", &newX, &newY);
                         if (parsed == 2) {
                             pnpOffsetX_inch = newX;
                             pnpOffsetY_inch = newY;
                             // Save to Preferences
                             preferences.begin("machineCfg", false);
                             preferences.putFloat("pnpOffX", pnpOffsetX_inch);
                             preferences.putFloat("pnpOffY", pnpOffsetY_inch);
                             preferences.end();
                             Serial.printf("[DEBUG] Set PnP Offset to X: %.2f, Y: %.2f\n", pnpOffsetX_inch, pnpOffsetY_inch);
                             // Send confirmation with all current settings
                             char msgBuffer[400]; // Increased size
                             sprintf(msgBuffer, "{\"status\":\"Ready\",\"message\":\"PnP offset updated.\",\"pnpOffsetX\":%.2f,\"pnpOffsetY\":%.2f,\"placeFirstXAbs\":%.2f,\"placeFirstYAbs\":%.2f,\"patXSpeed\":%.0f,\"patXAccel\":%.0f,\"patYSpeed\":%.0f,\"patYAccel\":%.0f,\"gridCols\":%d,\"gridRows\":%d,\"gapX\":%.3f,\"gapY\":%.3f}",
                                     pnpOffsetX_inch, pnpOffsetY_inch,
                                     placeFirstXAbsolute_inch, placeFirstYAbsolute_inch,
                                     patternXSpeed, patternXAccel, patternYSpeed, patternYAccel,
                                     placeGridCols, placeGridRows,
                                     placeGapX_inch, placeGapY_inch);
                             webSocket.broadcastTXT(msgBuffer);
                         } else {
                             Serial.println("[ERROR] Failed to parse SET_PNP_OFFSET values.");
                             webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid format for SET_PNP_OFFSET. Use: SET_PNP_OFFSET X Y\"}");
                         }
                     }
                 } else if (command.startsWith("SET_SPEED_ACCEL ")) {
                     Serial.println("WebSocket: Received SET_SPEED_ACCEL command.");
                     if (isMoving || isHoming) { // Allow setting even in PnP mode if idle? Maybe not best idea. Only allow when not moving/homing.
                         Serial.println("[DEBUG] SET_SPEED_ACCEL denied: Machine busy.");
                         webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Cannot set speed/accel while machine is busy.\"}");
                     } else {
                         float receivedXS, receivedXA, receivedYS, receivedYA;
                         // Use C-style string for sscanf - receive actual values (e.g., 20000)
                         int parsed = sscanf(command.c_str() + strlen("SET_SPEED_ACCEL "), "%f %f %f %f", &receivedXS, &receivedXA, &receivedYS, &receivedYA);
                         // Check if parsing was successful AND values are positive
                         if (parsed == 4 && receivedXS > 0 && receivedXA > 0 && receivedYS > 0 && receivedYA > 0) {
                            // NOTE: Assuming the JS now sends the actual values (e.g. 20000)
                            // If JS was sending the displayed values (e.g. 20), we would multiply here:
                            // patternXSpeed = receivedXS * 1000.0;
                            // patternXAccel = receivedXA * 1000.0;
                            // patternYSpeed = receivedYS * 1000.0;
                            // patternYAccel = receivedYA * 1000.0;

                             // Update variables directly with received actual values
                             patternXSpeed = receivedXS;
                             patternXAccel = receivedXA;
                             patternYSpeed = receivedYS;
                             patternYAccel = receivedYA;

                             // Save Speed/Accel to Preferences
                             preferences.begin("machineCfg", false); 
                             preferences.putFloat("patXSpd", patternXSpeed); 
                             preferences.putFloat("patXAcc", patternXAccel); 
                             preferences.putFloat("patYSpd", patternYSpeed); 
                             preferences.putFloat("patYAcc", patternYAccel); 
                             preferences.end();
                             Serial.printf("[DEBUG] Saved Speed/Accel to NVS: X(S:%.0f, A:%.0f), Y(S:%.0f, A:%.0f)\n", patternXSpeed, patternXAccel, patternYSpeed, patternYAccel);

                             // Send confirmation with all current settings (using actual values)
                             char msgBuffer[400]; // Increased size
                             sprintf(msgBuffer, "{\"status\":\"Ready\",\"message\":\"Speed/Accel updated.\",\"pnpOffsetX\":%.2f,\"pnpOffsetY\":%.2f,\"placeFirstXAbs\":%.2f,\"placeFirstYAbs\":%.2f,\"patXSpeed\":%.0f,\"patXAccel\":%.0f,\"patYSpeed\":%.0f,\"patYAccel\":%.0f,\"gridCols\":%d,\"gridRows\":%d,\"gapX\":%.3f,\"gapY\":%.3f}",
                                     pnpOffsetX_inch, pnpOffsetY_inch,
                                     placeFirstXAbsolute_inch, placeFirstYAbsolute_inch,
                                     patternXSpeed, patternXAccel, patternYSpeed, patternYAccel,
                                     placeGridCols, placeGridRows,
                                     placeGapX_inch, placeGapY_inch);
                             webSocket.broadcastTXT(msgBuffer);
                         } else {
                             Serial.println("[ERROR] Failed to parse SET_SPEED_ACCEL values or values invalid.");
                             webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid format/values for SET_SPEED_ACCEL. Use: SET_SPEED_ACCEL XS XA YS YA (all positive)\"}");
                         }
                     }
                 } else if (command.startsWith("SET_FIRST_PLACE_ABS ")) { // UPDATED
                         Serial.println("[DEBUG] webSocketEvent: Handling SET_FIRST_PLACE_ABS command."); // DEBUG
                         float newX, newY;
                    // Expecting "SET_FIRST_PLACE_ABS X_val Y_val"
                    int parsed = sscanf(command.c_str() + strlen("SET_FIRST_PLACE_ABS "), "%f %f", &newX, &newY);
                         if (parsed == 2) {
                        placeFirstXAbsolute_inch = newX;
                        placeFirstYAbsolute_inch = newY;
                             // Save to Preferences
                             preferences.begin("machineCfg", false);
                        preferences.putFloat("placeFirstXAbs", placeFirstXAbsolute_inch);
                        preferences.putFloat("placeFirstYAbs", placeFirstYAbsolute_inch);
                             preferences.end();
                        Serial.printf("[DEBUG] Set First Place Absolute to X: %.2f, Y: %.2f\n", placeFirstXAbsolute_inch, placeFirstYAbsolute_inch);
                             // Send confirmation with all current settings
                        char msgBuffer[400]; // Increased size
                        sprintf(msgBuffer, "{\"status\":\"Ready\",\"message\":\"First Place Absolute Pos updated.\",\"pnpOffsetX\":%.2f,\"pnpOffsetY\":%.2f,\"placeFirstXAbs\":%.2f,\"placeFirstYAbs\":%.2f,\"patXSpeed\":%.0f,\"patXAccel\":%.0f,\"patYSpeed\":%.0f,\"patYAccel\":%.0f,\"gridCols\":%d,\"gridRows\":%d,\"gapX\":%.3f,\"gapY\":%.3f}",
                                     pnpOffsetX_inch, pnpOffsetY_inch,
                                placeFirstXAbsolute_inch, placeFirstYAbsolute_inch,
                                     patternXSpeed, patternXAccel, patternYSpeed, patternYAccel,
                                     placeGridCols, placeGridRows,
                                     placeGapX_inch, placeGapY_inch);
                            webSocket.broadcastTXT(msgBuffer);
                         } else {
                        Serial.printf("[DEBUG] Failed to parse SET_FIRST_PLACE_ABS command: %s\n", command.c_str());
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid SET_FIRST_PLACE_ABS format.\"}");
                    }
                 }
                 // --- Calibration Commands ---
                 else if (command == "ENTER_CALIBRATION") {
                    Serial.println("WebSocket: Received ENTER_CALIBRATION command.");
                    if (!allHomed) {
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Machine must be homed before entering calibration.\"}");
                    } else if (isMoving || isHoming || inPickPlaceMode) {
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Machine busy. Cannot enter calibration.\"}");
                 } else {
                        inCalibrationMode = true;
                        webSocket.broadcastTXT("{\"status\":\"CalibrationActive\", \"message\":\"Calibration mode entered.\"}");
                        sendCurrentPositionUpdate(); // Send initial position
                    }
                 } else if (command == "EXIT_CALIBRATION") {
                    Serial.println("WebSocket: Received EXIT_CALIBRATION command.");
                    inCalibrationMode = false;
                    // Send a standard Ready status update when exiting
                    webSocket.broadcastTXT("{\"status\":\"Ready\", \"message\":\"Exited calibration mode.\"}");
                 } else if (command.startsWith("SET_OFFSET_FROM_CURRENT")) {
                    Serial.println("WebSocket: Received SET_OFFSET_FROM_CURRENT command.");
                     if (!inCalibrationMode) {
                         webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Must be in calibration mode.\"}");
                     } else if (isMoving || isHoming) {
                         webSocket.sendTXT(num, "{\"status\":\"Busy\", \"message\":\"Cannot set while moving.\"}");
                     } else {
                         if (stepper_x && stepper_y_left) { // Use Y-Left as reference
                            pnpOffsetX_inch = (float)stepper_x->getCurrentPosition() / STEPS_PER_INCH_XY;
                            pnpOffsetY_inch = (float)stepper_y_left->getCurrentPosition() / STEPS_PER_INCH_XY;
                            
                            preferences.begin("machineCfg", false);
                            preferences.putFloat("pnpOffX", pnpOffsetX_inch);
                            preferences.putFloat("pnpOffY", pnpOffsetY_inch);
                            preferences.end();
                            
                            Serial.printf("[DEBUG] Set PnP Offset from current pos to X: %.2f, Y: %.2f\n", pnpOffsetX_inch, pnpOffsetY_inch);
                             char msgBuffer[400]; // Increased size
                             sprintf(msgBuffer, "{\"status\":\"CalibrationActive\",\"message\":\"PnP Offset set from current position.\",\"pnpOffsetX\":%.2f,\"pnpOffsetY\":%.2f,\"placeFirstXAbs\":%.2f,\"placeFirstYAbs\":%.2f,\"patXSpeed\":%.0f,\"patXAccel\":%.0f,\"patYSpeed\":%.0f,\"patYAccel\":%.0f,\"gridCols\":%d,\"gridRows\":%d,\"gapX\":%.3f,\"gapY\":%.3f}",
                                     pnpOffsetX_inch, pnpOffsetY_inch,
                                     placeFirstXAbsolute_inch, placeFirstYAbsolute_inch,
                                     patternXSpeed, patternXAccel, patternYSpeed, patternYAccel,
                                     placeGridCols, placeGridRows,
                                     placeGapX_inch, placeGapY_inch);
                             webSocket.broadcastTXT(msgBuffer);
                         } else {
                              webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Steppers not available.\"}");
                         }
                     }
                 } else if (command == "SET_FIRST_PLACE_ABS_FROM_CURRENT") { // UPDATED
                     if (!inCalibrationMode) {
                         webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Must be in Calibration Mode to set First Place position from current.\"}");
                     } else {
                         if (stepper_x && stepper_y_left) { // Use Y-Left as reference
                             placeFirstXAbsolute_inch = (float)stepper_x->getCurrentPosition() / STEPS_PER_INCH_XY;
                             placeFirstYAbsolute_inch = (float)stepper_y_left->getCurrentPosition() / STEPS_PER_INCH_XY;
                            
                             preferences.begin("machineCfg", false);
                             preferences.putFloat("placeFirstXAbs", placeFirstXAbsolute_inch);
                             preferences.putFloat("placeFirstYAbs", placeFirstYAbsolute_inch);
                             preferences.end();
                            
                             Serial.printf("[DEBUG] Set First Place Absolute from current pos to X: %.2f, Y: %.2f\n", placeFirstXAbsolute_inch, placeFirstYAbsolute_inch);
                              char msgBuffer[400]; // Increased size
                               sprintf(msgBuffer, "{\"status\":\"CalibrationActive\",\"message\":\"First Place Absolute Pos set from current position.\",\"pnpOffsetX\":%.2f,\"pnpOffsetY\":%.2f,\"placeFirstXAbs\":%.2f,\"placeFirstYAbs\":%.2f,\"patXSpeed\":%.0f,\"patXAccel\":%.0f,\"patYSpeed\":%.0f,\"patYAccel\":%.0f,\"gridCols\":%d,\"gridRows\":%d,\"gapX\":%.3f,\"gapY\":%.3f}",
                                       pnpOffsetX_inch, pnpOffsetY_inch,
                                       placeFirstXAbsolute_inch, placeFirstYAbsolute_inch,
                                       patternXSpeed, patternXAccel, patternYSpeed, patternYAccel,
                                       placeGridCols, placeGridRows,
                                       placeGapX_inch, placeGapY_inch);
                              webSocket.broadcastTXT(msgBuffer);
                         } else {
                             Serial.println("[ERROR] Stepper X or Y_Left not initialized when setting First Place Abs from current.");
                             webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Internal stepper error.\"}");
                         }
                     }
                 } else if (command.startsWith("JOG ")) {
                    // Serial.println("WebSocket: Received JOG command.");
                    if (!inCalibrationMode) {
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Must be in calibration mode to jog.\"}");
                    } else if (isMoving || isHoming) {
                        webSocket.sendTXT(num, "{\"status\":\"Busy\", \"message\":\"Cannot jog while machine is moving.\"}");
                    } else {
                        char axis;
                        float distance_inch;
                        int parsed = sscanf(command.c_str() + strlen("JOG "), "%c %f", &axis, &distance_inch);
                        
                        if (parsed == 2) {
                            long current_steps = 0;
                            long jog_steps = 0;
                            FastAccelStepper* stepper_to_move = NULL;
                            float speed = 0, accel = 0;

                            if (axis == 'X' && stepper_x) {
                                stepper_to_move = stepper_x;
                                current_steps = stepper_x->getCurrentPosition();
                                jog_steps = (long)(distance_inch * STEPS_PER_INCH_XY);
                                speed = patternXSpeed;
                                accel = patternXAccel;
                            } else if (axis == 'Y' && stepper_y_left && stepper_y_right) { // Assuming both Y move together
                                stepper_to_move = stepper_y_left; // Use left for current pos, command both
                                current_steps = stepper_y_left->getCurrentPosition();
                                jog_steps = (long)(distance_inch * STEPS_PER_INCH_XY);
                                speed = patternYSpeed;
                                accel = patternYAccel;
                            } else {
                                Serial.printf("[ERROR] Invalid axis '%c' or stepper not available for JOG.\n", axis);
                                webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid axis for jog.\"}");
                            }

                            if (stepper_to_move) {
                                isMoving = true; // Set flag, loop() will handle completion
                                webSocket.broadcastTXT("{\"status\":\"Busy\", \"message\":\"Jogging...\"}");
                                
                                long target_steps = current_steps + jog_steps;
                                //Serial.printf("  Jogging %c by %.3f inches (%ld steps) from %ld to %ld\n", axis, distance_inch, jog_steps, current_steps, target_steps);

                                stepper_to_move->setSpeedInHz(speed);
                                stepper_to_move->setAcceleration(accel);
                                stepper_to_move->moveTo(target_steps);

                                if (axis == 'Y' && stepper_y_right) { // Command right Y too
                                    stepper_y_right->setSpeedInHz(speed);
                                    stepper_y_right->setAcceleration(accel);
                                    stepper_y_right->moveTo(target_steps);
                                }
                            }
                        } else {
                            Serial.println("[ERROR] Failed to parse JOG command.");
                            webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid JOG format. Use: JOG X/Y distance\"}");
                        }
                    }
                 } else if (command.startsWith("MOVE_TO_COORDS ")) {
                    Serial.println("WebSocket: Received MOVE_TO_COORDS command.");
                    if (!inCalibrationMode) {
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Must be in calibration mode to move to coordinates.\"}");
                    } else if (isMoving || isHoming) {
                        webSocket.sendTXT(num, "{\"status\":\"Busy\", \"message\":\"Cannot move while machine is busy.\"}");
                    } else {
                        float targetX_inch, targetY_inch;
                        int parsed = sscanf(command.c_str() + strlen("MOVE_TO_COORDS "), "%f %f", &targetX_inch, &targetY_inch);
                        
                        if (parsed == 2) {
                            // Validate coordinates (optional, add bounds checking if needed)
                            if (targetX_inch < 0 || targetY_inch < 0) {
                                webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid coordinates. Must be non-negative.\"}");
                                return;
                            }
                            
                            // Set up the move
                            isMoving = true; // Set flag, loop() will handle completion
                            webSocket.broadcastTXT("{\"status\":\"Busy\", \"message\":\"Moving to coordinates...\"}");
                            
                            // Convert to steps
                            long targetX_steps = (long)(targetX_inch * STEPS_PER_INCH_XY);
                            long targetY_steps = (long)(targetY_inch * STEPS_PER_INCH_XY);
                            
                            // Command the move
                            if (stepper_x) {
                                stepper_x->setSpeedInHz(patternXSpeed);
                                stepper_x->setAcceleration(patternXAccel);
                                stepper_x->moveTo(targetX_steps);
                            }
                            
                            if (stepper_y_left && stepper_y_right) {
                                stepper_y_left->setSpeedInHz(patternYSpeed);
                                stepper_y_left->setAcceleration(patternYAccel);
                                stepper_y_left->moveTo(targetY_steps);
                                
                                stepper_y_right->setSpeedInHz(patternYSpeed);
                                stepper_y_right->setAcceleration(patternYAccel);
                                stepper_y_right->moveTo(targetY_steps);
                            }
                        } else {
                            Serial.println("[ERROR] Failed to parse MOVE_TO_COORDS command.");
                            webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid format. Use: MOVE_TO_COORDS X Y\"}");
                         }
                     }
                 } else if (command.startsWith("SET_GRID_SPACING ")) { // UPDATED
                    Serial.println("[DEBUG] webSocketEvent: Handling SET_GRID_SPACING command."); // DEBUG
                        int newCols, newRows;
                    // Expecting "SET_GRID_SPACING C R"
                    int parsed = sscanf(command.c_str() + strlen("SET_GRID_SPACING "), "%d %d", &newCols, &newRows);
                    if (parsed == 2 && newCols > 0 && newRows > 0) {
                        // Call the new calculation function
                        calculateAndSetGridSpacing(newCols, newRows);
                    } else {
                        Serial.printf("[DEBUG] Failed to parse SET_GRID_SPACING command: %s\n", command.c_str());
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid SET_GRID_SPACING format. Use C R (integers > 0)\"}");
                    }
                 } else if (command.startsWith("SET_TRAY_SIZE ")) { // NEW
                    Serial.println("[DEBUG] webSocketEvent: Handling SET_TRAY_SIZE command."); // DEBUG
                    float newW, newH;
                    // Expecting "SET_TRAY_SIZE W H"
                    int parsed = sscanf(command.c_str() + strlen("SET_TRAY_SIZE "), "%f %f", &newW, &newH);
                    if (parsed == 2 && newW > 0 && newH > 0) {
                        Serial.printf("[DEBUG] New tray dimensions: width=%.2f, height=%.2f (old: width=%.2f, height=%.2f)\n", 
                                    newW, newH, trayWidth_inch, trayHeight_inch);
                        
                        // Save the new tray dimensions
                        trayWidth_inch = newW;
                        trayHeight_inch = newH;
                        
                        // Open preferences, save values, and close immediately
                        preferences.begin("machineCfg", false);
                        preferences.putFloat("trayWidth", trayWidth_inch);
                        preferences.putFloat("trayHeight", trayHeight_inch);
                        preferences.end();
                        
                        Serial.printf("[DEBUG] Set Tray Size to W=%.2f, H=%.2f\n", trayWidth_inch, trayHeight_inch);
                        
                        // Recalculate grid spacing with current grid dimensions to reflect new tray size
                        float oldGapX = placeGapX_inch;
                        float oldGapY = placeGapY_inch;
                        calculateAndSetGridSpacing(placeGridCols, placeGridRows);
                        
                        Serial.printf("[DEBUG] Gap values changed: X: %.3f  %.3f, Y: %.3f  %.3f\n", 
                                    oldGapX, placeGapX_inch, oldGapY, placeGapY_inch);
                        
                        // Instead of using a redundant call to sendAllSettingsUpdate, create a more specific message
                        // about the changes that were made
                        char msgBuffer[200];
                        sprintf(msgBuffer, "Tray Size updated to W=%.2f, H=%.2f. Gap recalculated: X=%.3f, Y=%.3f", 
                               trayWidth_inch, trayHeight_inch, placeGapX_inch, placeGapY_inch);
                        
                        // Send settings update to the specific client that requested the change
                        sendAllSettingsUpdate(num, msgBuffer);
                        // Also broadcast to all other clients
                        if (num != 255) {
                            sendAllSettingsUpdate(255, msgBuffer);
                        }
                    } else {
                        Serial.printf("[DEBUG] Failed to parse SET_TRAY_SIZE command: %s\n", command.c_str());
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid SET_TRAY_SIZE format.\"}");
                    }
                 } else if (command.startsWith("SET_PAINT_PATTERN_OFFSET ")) {
                    Serial.println("WebSocket: Received SET_PAINT_PATTERN_OFFSET command.");
                    if (isMoving || isHoming) { // Prevent changes while moving
                        webSocket.sendTXT(num, "{\"status\":\"Busy\",\"message\":\"Cannot set paint offsets while machine is busy.\"}");
                    } else {
                        float newX, newY;
                        int parsed = sscanf(command.c_str() + strlen("SET_PAINT_PATTERN_OFFSET "), "%f %f", &newX, &newY);
                        if (parsed == 2) {
                            paintPatternOffsetX_inch = newX;
                            paintPatternOffsetY_inch = newY;
                            // Save to Preferences
                            preferences.begin("machineCfg", false);
                            preferences.putFloat("paintPatOffX", paintPatternOffsetX_inch);
                            preferences.putFloat("paintPatOffY", paintPatternOffsetY_inch);
                            preferences.end();
                            Serial.printf("[DEBUG] Set Paint Pattern Offset to X: %.2f, Y: %.2f\n", paintPatternOffsetX_inch, paintPatternOffsetY_inch);
                            // Send confirmation with all settings
                            sendAllSettingsUpdate(num, "Paint Pattern Offset updated.");
                        } else {
                            webSocket.sendTXT(num, "{\"status\":\"Error\",\"message\":\"Invalid SET_PAINT_PATTERN_OFFSET format. Use: SET_PAINT_PATTERN_OFFSET X Y\"}");
                        }
                    }
                } else if (command.startsWith("SET_PAINT_GUN_OFFSET ")) {
                    Serial.println("WebSocket: Received SET_PAINT_GUN_OFFSET command.");
                     if (isMoving || isHoming) { // Prevent changes while moving
                        webSocket.sendTXT(num, "{\"status\":\"Busy\",\"message\":\"Cannot set paint offsets while machine is busy.\"}");
                    } else {
                        float newX, newY;
                        int parsed = sscanf(command.c_str() + strlen("SET_PAINT_GUN_OFFSET "), "%f %f", &newX, &newY);
                        if (parsed == 2) {
                            paintGunOffsetX_inch = newX;
                            paintGunOffsetY_inch = newY;
                            // Save to Preferences
                            preferences.begin("machineCfg", false);
                            preferences.putFloat("paintGunOffX", paintGunOffsetX_inch);
                            preferences.putFloat("paintGunOffY", paintGunOffsetY_inch);
                            preferences.end();
                            Serial.printf("[DEBUG] Set Paint Gun Offset to X: %.2f, Y: %.2f\n", paintGunOffsetX_inch, paintGunOffsetY_inch);
                            // Send confirmation with all settings
                            sendAllSettingsUpdate(num, "Paint Gun Offset updated.");
                        } else {
                            webSocket.sendTXT(num, "{\"status\":\"Error\",\"message\":\"Invalid SET_PAINT_GUN_OFFSET format. Use: SET_PAINT_GUN_OFFSET X Y\"}");
                        }
                    }
                } else if (command.startsWith("SET_PAINT_SIDE_SETTINGS ")) {
                    // Format: SET_PAINT_SIDE_SETTINGS sideIndex z pitch roll gun_orientation speed
                    Serial.println("WebSocket: Received SET_PAINT_SIDE_SETTINGS command.");
                    
                    // Parse command to extract parameters
                    String parts[6]; // Need 6 parts: sideIndex, z, pitch, roll, gunOrientation, speed
                    int partCount = 0;
                    int startPos = 23; // Skip "SET_PAINT_SIDE_SETTINGS "
                    
                    for (int i = 0; i < 6 && startPos < command.length(); i++) {
                        int spacePos = command.indexOf(' ', startPos);
                        if (spacePos == -1) {
                            // Last part
                            if (startPos < command.length()) {
                                parts[i] = command.substring(startPos);
                                partCount++;
                            }
                            break;
                        } else {
                            parts[i] = command.substring(startPos, spacePos);
                            startPos = spacePos + 1;
                            partCount++;
                        }
                    }
                    
                    if (partCount == 6) {
                        int sideIndex = parts[0].toInt();
                        float newZ = parts[1].toFloat();
                        int newPitch = parts[2].toInt();
                        int newRoll = parts[3].toInt();
                        int newGunOrientation = parts[4].toInt();
                        float newSpeed = parts[5].toFloat();
                        
                        // Validate parameters
                        if (sideIndex < 0 || sideIndex > 3) {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid side index\"}");
                            return;
                        }
                        
                        // Handle Z
                        if (newZ >= 0.0 && newZ <= 2.5) {
                            paintZHeight_inch[sideIndex] = newZ;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid Z height (must be between 0.0 and 2.5)\"}");
                            return;
                        }
                        
                        // Handle Pitch
                        if (newPitch >= 0 && newPitch <= 90) {
                            paintPitchAngle[sideIndex] = newPitch;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid pitch angle (must be between 0 and 90)\"}");
                            return;
                        }
                        
                        // Handle Roll
                        if (newRoll == 0 || newRoll == 90) {
                            paintRollAngle[sideIndex] = newRoll;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid roll angle (must be 0 or 90)\"}");
                            return;
                        }
                        
                        // Handle Gun Orientation
                        if (newGunOrientation == 0 || newGunOrientation == 90) {
                            paintGunOrientation[sideIndex] = newGunOrientation;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid gun orientation (must be 0 or 90)\"}");
                            return;
                        }
                        
                        // Handle Speed
                        if (newSpeed >= 5000.0 && newSpeed <= 25000.0) {
                            paintSpeed[sideIndex] = newSpeed;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid speed (must be between 5000 and 25000)\"}");
                            return;
                        }
                        
                        // Save to preferences
                        preferences.begin("paintSettings", false);
                        String keyZ = "paintZ_" + String(sideIndex);
                        String keyP = "paintP_" + String(sideIndex);
                        String keyR = "paintR_" + String(sideIndex);
                        String keyGO = "paintGO_" + String(sideIndex);
                        String keyS = "paintS_" + String(sideIndex);
                        
                        preferences.putFloat(keyZ.c_str(), paintZHeight_inch[sideIndex]);
                        preferences.putInt(keyP.c_str(), paintPitchAngle[sideIndex]);
                        preferences.putInt(keyR.c_str(), paintRollAngle[sideIndex]);
                        preferences.putInt(keyGO.c_str(), paintGunOrientation[sideIndex]);
                        preferences.putFloat(keyS.c_str(), paintSpeed[sideIndex]);
                        preferences.end();
                        
                        // Send response with updated values
                        char response[100];
                        sprintf(response, "{\"status\":\"Ready\", \"message\":\"Updated settings for side %d: Z=%.2f, P=%d, R=%d, GO=%d, S=%.1f\"}", 
                                sideIndex, paintZHeight_inch[sideIndex], paintPitchAngle[sideIndex], 
                                paintRollAngle[sideIndex], paintGunOrientation[sideIndex], paintSpeed[sideIndex]);
                        webSocket.broadcastTXT(response);
                        
                        // Also update all settings everywhere
                        sendAllSettingsUpdate(ALL_CLIENTS, "");
                    } else {
                        webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid SET_PAINT_SIDE_SETTINGS format\"}");
                    }
                } else if (command.startsWith("JOG ")) {
                    // Serial.println("WebSocket: Received JOG command.");
                    if (!inCalibrationMode) {
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Must be in calibration mode to jog.\"}");
                    } else if (isMoving || isHoming) {
                        webSocket.sendTXT(num, "{\"status\":\"Busy\", \"message\":\"Cannot jog while machine is moving.\"}");
                    } else {
                        char axis;
                        float distance_inch;
                        int parsed = sscanf(command.c_str() + strlen("JOG "), "%c %f", &axis, &distance_inch);
                        
                        if (parsed == 2) {
                            long current_steps = 0;
                            long jog_steps = 0;
                            FastAccelStepper* stepper_to_move = NULL;
                            float speed = 0, accel = 0;

                            if (axis == 'X' && stepper_x) {
                                stepper_to_move = stepper_x;
                                current_steps = stepper_x->getCurrentPosition();
                                jog_steps = (long)(distance_inch * STEPS_PER_INCH_XY);
                                speed = patternXSpeed;
                                accel = patternXAccel;
                            } else if (axis == 'Y' && stepper_y_left && stepper_y_right) { // Assuming both Y move together
                                stepper_to_move = stepper_y_left; // Use left for current pos, command both
                                current_steps = stepper_y_left->getCurrentPosition();
                                jog_steps = (long)(distance_inch * STEPS_PER_INCH_XY);
                                speed = patternYSpeed;
                                accel = patternYAccel;
                            } else {
                                Serial.printf("[ERROR] Invalid axis '%c' or stepper not available for JOG.\n", axis);
                                webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid axis for jog.\"}");
                            }

                            if (stepper_to_move) {
                                isMoving = true; // Set flag, loop() will handle completion
                                webSocket.broadcastTXT("{\"status\":\"Busy\", \"message\":\"Jogging...\"}");
                                
                                long target_steps = current_steps + jog_steps;
                                //Serial.printf("  Jogging %c by %.3f inches (%ld steps) from %ld to %ld\n", axis, distance_inch, jog_steps, current_steps, target_steps);

                                stepper_to_move->setSpeedInHz(speed);
                                stepper_to_move->setAcceleration(accel);
                                stepper_to_move->moveTo(target_steps);

                                if (axis == 'Y' && stepper_y_right) { // Command right Y too
                                    stepper_y_right->setSpeedInHz(speed);
                                    stepper_y_right->setAcceleration(accel);
                                    stepper_y_right->moveTo(target_steps);
                                }
                            }
                        } else {
                            Serial.println("[ERROR] Failed to parse JOG command.");
                            webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid JOG format. Use: JOG X/Y distance\"}");
                        }
                    }
                 } else if (command.startsWith("MOVE_TO_COORDS ")) {
                    Serial.println("WebSocket: Received MOVE_TO_COORDS command.");
                    if (!inCalibrationMode) {
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Must be in calibration mode to move to coordinates.\"}");
                    } else if (isMoving || isHoming) {
                        webSocket.sendTXT(num, "{\"status\":\"Busy\", \"message\":\"Cannot move while machine is busy.\"}");
                    } else {
                        float targetX_inch, targetY_inch;
                        int parsed = sscanf(command.c_str() + strlen("MOVE_TO_COORDS "), "%f %f", &targetX_inch, &targetY_inch);
                        
                        if (parsed == 2) {
                            // Validate coordinates (optional, add bounds checking if needed)
                            if (targetX_inch < 0 || targetY_inch < 0) {
                                webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid coordinates. Must be non-negative.\"}");
                                return;
                            }
                            
                            // Set up the move
                            isMoving = true; // Set flag, loop() will handle completion
                            webSocket.broadcastTXT("{\"status\":\"Busy\", \"message\":\"Moving to coordinates...\"}");
                            
                            // Convert to steps
                            long targetX_steps = (long)(targetX_inch * STEPS_PER_INCH_XY);
                            long targetY_steps = (long)(targetY_inch * STEPS_PER_INCH_XY);
                            
                            // Command the move
                            if (stepper_x) {
                                stepper_x->setSpeedInHz(patternXSpeed);
                                stepper_x->setAcceleration(patternXAccel);
                                stepper_x->moveTo(targetX_steps);
                            }
                            
                            if (stepper_y_left && stepper_y_right) {
                                stepper_y_left->setSpeedInHz(patternYSpeed);
                                stepper_y_left->setAcceleration(patternYAccel);
                                stepper_y_left->moveTo(targetY_steps);
                                
                                stepper_y_right->setSpeedInHz(patternYSpeed);
                                stepper_y_right->setAcceleration(patternYAccel);
                                stepper_y_right->moveTo(targetY_steps);
                            }
                        } else {
                            Serial.println("[ERROR] Failed to parse MOVE_TO_COORDS command.");
                            webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid format. Use: MOVE_TO_COORDS X Y\"}");
                         }
                     }
                 } else if (command.startsWith("SET_GRID_SPACING ")) { // UPDATED
                    Serial.println("[DEBUG] webSocketEvent: Handling SET_GRID_SPACING command."); // DEBUG
                        int newCols, newRows;
                    // Expecting "SET_GRID_SPACING C R"
                    int parsed = sscanf(command.c_str() + strlen("SET_GRID_SPACING "), "%d %d", &newCols, &newRows);
                    if (parsed == 2 && newCols > 0 && newRows > 0) {
                        // Call the new calculation function
                        calculateAndSetGridSpacing(newCols, newRows);
                    } else {
                        Serial.printf("[DEBUG] Failed to parse SET_GRID_SPACING command: %s\n", command.c_str());
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid SET_GRID_SPACING format. Use C R (integers > 0)\"}");
                    }
                 } else if (command.startsWith("SET_TRAY_SIZE ")) { // NEW
                    Serial.println("[DEBUG] webSocketEvent: Handling SET_TRAY_SIZE command."); // DEBUG
                    float newW, newH;
                    // Expecting "SET_TRAY_SIZE W H"
                    int parsed = sscanf(command.c_str() + strlen("SET_TRAY_SIZE "), "%f %f", &newW, &newH);
                    if (parsed == 2 && newW > 0 && newH > 0) {
                        Serial.printf("[DEBUG] New tray dimensions: width=%.2f, height=%.2f (old: width=%.2f, height=%.2f)\n", 
                                    newW, newH, trayWidth_inch, trayHeight_inch);
                        
                        // Save the new tray dimensions
                        trayWidth_inch = newW;
                        trayHeight_inch = newH;
                        
                        // Open preferences, save values, and close immediately
                        preferences.begin("machineCfg", false);
                        preferences.putFloat("trayWidth", trayWidth_inch);
                        preferences.putFloat("trayHeight", trayHeight_inch);
                        preferences.end();
                        
                        Serial.printf("[DEBUG] Set Tray Size to W=%.2f, H=%.2f\n", trayWidth_inch, trayHeight_inch);
                        
                        // Recalculate grid spacing with current grid dimensions to reflect new tray size
                        float oldGapX = placeGapX_inch;
                        float oldGapY = placeGapY_inch;
                        calculateAndSetGridSpacing(placeGridCols, placeGridRows);
                        
                        Serial.printf("[DEBUG] Gap values changed: X: %.3f  %.3f, Y: %.3f  %.3f\n", 
                                    oldGapX, placeGapX_inch, oldGapY, placeGapY_inch);
                        
                        // Instead of using a redundant call to sendAllSettingsUpdate, create a more specific message
                        // about the changes that were made
                        char msgBuffer[200];
                        sprintf(msgBuffer, "Tray Size updated to W=%.2f, H=%.2f. Gap recalculated: X=%.3f, Y=%.3f", 
                               trayWidth_inch, trayHeight_inch, placeGapX_inch, placeGapY_inch);
                        
                        // Send settings update to the specific client that requested the change
                        sendAllSettingsUpdate(num, msgBuffer);
                        // Also broadcast to all other clients
                        if (num != 255) {
                            sendAllSettingsUpdate(255, msgBuffer);
                        }
                    } else {
                        Serial.printf("[DEBUG] Failed to parse SET_TRAY_SIZE command: %s\n", command.c_str());
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid SET_TRAY_SIZE format.\"}");
                    }
                 } else if (command.startsWith("SET_PAINT_PATTERN_OFFSET ")) {
                    Serial.println("WebSocket: Received SET_PAINT_PATTERN_OFFSET command.");
                    if (isMoving || isHoming) { // Prevent changes while moving
                        webSocket.sendTXT(num, "{\"status\":\"Busy\",\"message\":\"Cannot set paint offsets while machine is busy.\"}");
                    } else {
                        float newX, newY;
                        int parsed = sscanf(command.c_str() + strlen("SET_PAINT_PATTERN_OFFSET "), "%f %f", &newX, &newY);
                        if (parsed == 2) {
                            paintPatternOffsetX_inch = newX;
                            paintPatternOffsetY_inch = newY;
                            // Save to Preferences
                            preferences.begin("machineCfg", false);
                            preferences.putFloat("paintPatOffX", paintPatternOffsetX_inch);
                            preferences.putFloat("paintPatOffY", paintPatternOffsetY_inch);
                            preferences.end();
                            Serial.printf("[DEBUG] Set Paint Pattern Offset to X: %.2f, Y: %.2f\n", paintPatternOffsetX_inch, paintPatternOffsetY_inch);
                            // Send confirmation with all settings
                            sendAllSettingsUpdate(num, "Paint Pattern Offset updated.");
                        } else {
                            webSocket.sendTXT(num, "{\"status\":\"Error\",\"message\":\"Invalid SET_PAINT_PATTERN_OFFSET format. Use: SET_PAINT_PATTERN_OFFSET X Y\"}");
                        }
                    }
                } else if (command.startsWith("SET_PAINT_GUN_OFFSET ")) {
                    Serial.println("WebSocket: Received SET_PAINT_GUN_OFFSET command.");
                     if (isMoving || isHoming) { // Prevent changes while moving
                        webSocket.sendTXT(num, "{\"status\":\"Busy\",\"message\":\"Cannot set paint offsets while machine is busy.\"}");
                    } else {
                        float newX, newY;
                        int parsed = sscanf(command.c_str() + strlen("SET_PAINT_GUN_OFFSET "), "%f %f", &newX, &newY);
                        if (parsed == 2) {
                            paintGunOffsetX_inch = newX;
                            paintGunOffsetY_inch = newY;
                            // Save to Preferences
                            preferences.begin("machineCfg", false);
                            preferences.putFloat("paintGunOffX", paintGunOffsetX_inch);
                            preferences.putFloat("paintGunOffY", paintGunOffsetY_inch);
                            preferences.end();
                            Serial.printf("[DEBUG] Set Paint Gun Offset to X: %.2f, Y: %.2f\n", paintGunOffsetX_inch, paintGunOffsetY_inch);
                            // Send confirmation with all settings
                            sendAllSettingsUpdate(num, "Paint Gun Offset updated.");
                        } else {
                            webSocket.sendTXT(num, "{\"status\":\"Error\",\"message\":\"Invalid SET_PAINT_GUN_OFFSET format. Use: SET_PAINT_GUN_OFFSET X Y\"}");
                        }
                    }
                } else if (command.startsWith("SET_PAINT_SIDE_SETTINGS ")) {
                    // Format: SET_PAINT_SIDE_SETTINGS sideIndex z pitch roll gun_orientation speed
                    Serial.println("WebSocket: Received SET_PAINT_SIDE_SETTINGS command.");
                    
                    // Parse command to extract parameters
                    String parts[6]; // Need 6 parts: sideIndex, z, pitch, roll, gunOrientation, speed
                    int partCount = 0;
                    int startPos = 23; // Skip "SET_PAINT_SIDE_SETTINGS "
                    
                    for (int i = 0; i < 6 && startPos < command.length(); i++) {
                        int spacePos = command.indexOf(' ', startPos);
                        if (spacePos == -1) {
                            // Last part
                            if (startPos < command.length()) {
                                parts[i] = command.substring(startPos);
                                partCount++;
                            }
                            break;
                        } else {
                            parts[i] = command.substring(startPos, spacePos);
                            startPos = spacePos + 1;
                            partCount++;
                        }
                    }
                    
                    if (partCount == 6) {
                        int sideIndex = parts[0].toInt();
                        float newZ = parts[1].toFloat();
                        int newPitch = parts[2].toInt();
                        int newRoll = parts[3].toInt();
                        int newGunOrientation = parts[4].toInt();
                        float newSpeed = parts[5].toFloat();
                        
                        // Validate parameters
                        if (sideIndex < 0 || sideIndex > 3) {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid side index\"}");
                            return;
                        }
                        
                        // Handle Z
                        if (newZ >= 0.0 && newZ <= 2.5) {
                            paintZHeight_inch[sideIndex] = newZ;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid Z height (must be between 0.0 and 2.5)\"}");
                            return;
                        }
                        
                        // Handle Pitch
                        if (newPitch >= 0 && newPitch <= 90) {
                            paintPitchAngle[sideIndex] = newPitch;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid pitch angle (must be between 0 and 90)\"}");
                            return;
                        }
                        
                        // Handle Roll
                        if (newRoll == 0 || newRoll == 90) {
                            paintRollAngle[sideIndex] = newRoll;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid roll angle (must be 0 or 90)\"}");
                            return;
                        }
                        
                        // Handle Gun Orientation
                        if (newGunOrientation == 0 || newGunOrientation == 90) {
                            paintGunOrientation[sideIndex] = newGunOrientation;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid gun orientation (must be 0 or 90)\"}");
                            return;
                        }
                        
                        // Handle Speed
                        if (newSpeed >= 5000.0 && newSpeed <= 25000.0) {
                            paintSpeed[sideIndex] = newSpeed;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid speed (must be between 5000 and 25000)\"}");
                            return;
                        }
                        
                        // Save to preferences
                        preferences.begin("paintSettings", false);
                        String keyZ = "paintZ_" + String(sideIndex);
                        String keyP = "paintP_" + String(sideIndex);
                        String keyR = "paintR_" + String(sideIndex);
                        String keyGO = "paintGO_" + String(sideIndex);
                        String keyS = "paintS_" + String(sideIndex);
                        
                        preferences.putFloat(keyZ.c_str(), paintZHeight_inch[sideIndex]);
                        preferences.putInt(keyP.c_str(), paintPitchAngle[sideIndex]);
                        preferences.putInt(keyR.c_str(), paintRollAngle[sideIndex]);
                        preferences.putInt(keyGO.c_str(), paintGunOrientation[sideIndex]);
                        preferences.putFloat(keyS.c_str(), paintSpeed[sideIndex]);
                        preferences.end();
                        
                        // Send response with updated values
                        char response[100];
                        sprintf(response, "{\"status\":\"Ready\", \"message\":\"Updated settings for side %d: Z=%.2f, P=%d, R=%d, GO=%d, S=%.1f\"}", 
                                sideIndex, paintZHeight_inch[sideIndex], paintPitchAngle[sideIndex], 
                                paintRollAngle[sideIndex], paintGunOrientation[sideIndex], paintSpeed[sideIndex]);
                        webSocket.broadcastTXT(response);
                        
                        // Also update all settings everywhere
                        sendAllSettingsUpdate(ALL_CLIENTS, "");
                    } else {
                        webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid SET_PAINT_SIDE_SETTINGS format\"}");
                    }
                } else if (command.startsWith("JOG ")) {
                    // Serial.println("WebSocket: Received JOG command.");
                    if (!inCalibrationMode) {
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Must be in calibration mode to jog.\"}");
                    } else if (isMoving || isHoming) {
                        webSocket.sendTXT(num, "{\"status\":\"Busy\", \"message\":\"Cannot jog while machine is moving.\"}");
                    } else {
                        char axis;
                        float distance_inch;
                        int parsed = sscanf(command.c_str() + strlen("JOG "), "%c %f", &axis, &distance_inch);
                        
                        if (parsed == 2) {
                            long current_steps = 0;
                            long jog_steps = 0;
                            FastAccelStepper* stepper_to_move = NULL;
                            float speed = 0, accel = 0;

                            if (axis == 'X' && stepper_x) {
                                stepper_to_move = stepper_x;
                                current_steps = stepper_x->getCurrentPosition();
                                jog_steps = (long)(distance_inch * STEPS_PER_INCH_XY);
                                speed = patternXSpeed;
                                accel = patternXAccel;
                            } else if (axis == 'Y' && stepper_y_left && stepper_y_right) { // Assuming both Y move together
                                stepper_to_move = stepper_y_left; // Use left for current pos, command both
                                current_steps = stepper_y_left->getCurrentPosition();
                                jog_steps = (long)(distance_inch * STEPS_PER_INCH_XY);
                                speed = patternYSpeed;
                                accel = patternYAccel;
                            } else {
                                Serial.printf("[ERROR] Invalid axis '%c' or stepper not available for JOG.\n", axis);
                                webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid axis for jog.\"}");
                            }

                            if (stepper_to_move) {
                                isMoving = true; // Set flag, loop() will handle completion
                                webSocket.broadcastTXT("{\"status\":\"Busy\", \"message\":\"Jogging...\"}");
                                
                                long target_steps = current_steps + jog_steps;
                                //Serial.printf("  Jogging %c by %.3f inches (%ld steps) from %ld to %ld\n", axis, distance_inch, jog_steps, current_steps, target_steps);

                                stepper_to_move->setSpeedInHz(speed);
                                stepper_to_move->setAcceleration(accel);
                                stepper_to_move->moveTo(target_steps);

                                if (axis == 'Y' && stepper_y_right) { // Command right Y too
                                    stepper_y_right->setSpeedInHz(speed);
                                    stepper_y_right->setAcceleration(accel);
                                    stepper_y_right->moveTo(target_steps);
                                }
                            }
                        } else {
                            Serial.println("[ERROR] Failed to parse JOG command.");
                            webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid JOG format. Use: JOG X/Y distance\"}");
                        }
                    }
                 } else if (command.startsWith("MOVE_TO_COORDS ")) {
                    Serial.println("WebSocket: Received MOVE_TO_COORDS command.");
                    if (!inCalibrationMode) {
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Must be in calibration mode to move to coordinates.\"}");
                    } else if (isMoving || isHoming) {
                        webSocket.sendTXT(num, "{\"status\":\"Busy\", \"message\":\"Cannot move while machine is busy.\"}");
                    } else {
                        float targetX_inch, targetY_inch;
                        int parsed = sscanf(command.c_str() + strlen("MOVE_TO_COORDS "), "%f %f", &targetX_inch, &targetY_inch);
                        
                        if (parsed == 2) {
                            // Validate coordinates (optional, add bounds checking if needed)
                            if (targetX_inch < 0 || targetY_inch < 0) {
                                webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid coordinates. Must be non-negative.\"}");
                                return;
                            }
                            
                            // Set up the move
                            isMoving = true; // Set flag, loop() will handle completion
                            webSocket.broadcastTXT("{\"status\":\"Busy\", \"message\":\"Moving to coordinates...\"}");
                            
                            // Convert to steps
                            long targetX_steps = (long)(targetX_inch * STEPS_PER_INCH_XY);
                            long targetY_steps = (long)(targetY_inch * STEPS_PER_INCH_XY);
                            
                            // Command the move
                            if (stepper_x) {
                                stepper_x->setSpeedInHz(patternXSpeed);
                                stepper_x->setAcceleration(patternXAccel);
                                stepper_x->moveTo(targetX_steps);
                            }
                            
                            if (stepper_y_left && stepper_y_right) {
                                stepper_y_left->setSpeedInHz(patternYSpeed);
                                stepper_y_left->setAcceleration(patternYAccel);
                                stepper_y_left->moveTo(targetY_steps);
                                
                                stepper_y_right->setSpeedInHz(patternYSpeed);
                                stepper_y_right->setAcceleration(patternYAccel);
                                stepper_y_right->moveTo(targetY_steps);
                            }
                        } else {
                            Serial.println("[ERROR] Failed to parse MOVE_TO_COORDS command.");
                            webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid format. Use: MOVE_TO_COORDS X Y\"}");
                         }
                     }
                 } else if (command.startsWith("SET_GRID_SPACING ")) { // UPDATED
                    Serial.println("[DEBUG] webSocketEvent: Handling SET_GRID_SPACING command."); // DEBUG
                    int newCols, newRows;
                    // Expecting "SET_GRID_SPACING C R"
                    int parsed = sscanf(command.c_str() + strlen("SET_GRID_SPACING "), "%d %d", &newCols, &newRows);
                    if (parsed == 2 && newCols > 0 && newRows > 0) {
                        // Call the new calculation function
                        calculateAndSetGridSpacing(newCols, newRows);
                    } else {
                        Serial.printf("[DEBUG] Failed to parse SET_GRID_SPACING command: %s\n", command.c_str());
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid SET_GRID_SPACING format. Use C R (integers > 0)\"}");
                    }
                 } else if (command.startsWith("SET_TRAY_SIZE ")) { // NEW
                    Serial.println("[DEBUG] webSocketEvent: Handling SET_TRAY_SIZE command."); // DEBUG
                    float newW, newH;
                    // Expecting "SET_TRAY_SIZE W H"
                    int parsed = sscanf(command.c_str() + strlen("SET_TRAY_SIZE "), "%f %f", &newW, &newH);
                    if (parsed == 2 && newW > 0 && newH > 0) {
                        Serial.printf("[DEBUG] New tray dimensions: width=%.2f, height=%.2f (old: width=%.2f, height=%.2f)\n", 
                                    newW, newH, trayWidth_inch, trayHeight_inch);
                        
                        // Save the new tray dimensions
                        trayWidth_inch = newW;
                        trayHeight_inch = newH;
                        
                        // Open preferences, save values, and close immediately
                        preferences.begin("machineCfg", false);
                        preferences.putFloat("trayWidth", trayWidth_inch);
                        preferences.putFloat("trayHeight", trayHeight_inch);
                        preferences.end();
                        
                        Serial.printf("[DEBUG] Set Tray Size to W=%.2f, H=%.2f\n", trayWidth_inch, trayHeight_inch);
                        
                        // Recalculate grid spacing with current grid dimensions to reflect new tray size
                        float oldGapX = placeGapX_inch;
                        float oldGapY = placeGapY_inch;
                        calculateAndSetGridSpacing(placeGridCols, placeGridRows);
                        
                        Serial.printf("[DEBUG] Gap values changed: X: %.3f  %.3f, Y: %.3f  %.3f\n", 
                                    oldGapX, placeGapX_inch, oldGapY, placeGapY_inch);
                        
                        // Instead of using a redundant call to sendAllSettingsUpdate, create a more specific message
                        // about the changes that were made
                        char msgBuffer[200];
                        sprintf(msgBuffer, "Tray Size updated to W=%.2f, H=%.2f. Gap recalculated: X=%.3f, Y=%.3f", 
                               trayWidth_inch, trayHeight_inch, placeGapX_inch, placeGapY_inch);
                        
                        // Send settings update to the specific client that requested the change
                        sendAllSettingsUpdate(num, msgBuffer);
                        // Also broadcast to all other clients
                        if (num != 255) {
                            sendAllSettingsUpdate(255, msgBuffer);
                        }
                    } else {
                        Serial.printf("[DEBUG] Failed to parse SET_TRAY_SIZE command: %s\n", command.c_str());
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid SET_TRAY_SIZE format.\"}");
                    }
                 } else if (command.startsWith("SET_PAINT_PATTERN_OFFSET ")) {
                    Serial.println("WebSocket: Received SET_PAINT_PATTERN_OFFSET command.");
                    if (isMoving || isHoming) { // Prevent changes while moving
                        webSocket.sendTXT(num, "{\"status\":\"Busy\",\"message\":\"Cannot set paint offsets while machine is busy.\"}");
                    } else {
                        float newX, newY;
                        int parsed = sscanf(command.c_str() + strlen("SET_PAINT_PATTERN_OFFSET "), "%f %f", &newX, &newY);
                        if (parsed == 2) {
                            paintPatternOffsetX_inch = newX;
                            paintPatternOffsetY_inch = newY;
                            // Save to Preferences
                            preferences.begin("machineCfg", false);
                            preferences.putFloat("paintPatOffX", paintPatternOffsetX_inch);
                            preferences.putFloat("paintPatOffY", paintPatternOffsetY_inch);
                            preferences.end();
                            Serial.printf("[DEBUG] Set Paint Pattern Offset to X: %.2f, Y: %.2f\n", paintPatternOffsetX_inch, paintPatternOffsetY_inch);
                            // Send confirmation with all settings
                            sendAllSettingsUpdate(num, "Paint Pattern Offset updated.");
                        } else {
                            webSocket.sendTXT(num, "{\"status\":\"Error\",\"message\":\"Invalid SET_PAINT_PATTERN_OFFSET format. Use: SET_PAINT_PATTERN_OFFSET X Y\"}");
                        }
                    }
                } else if (command.startsWith("SET_PAINT_GUN_OFFSET ")) {
                    Serial.println("WebSocket: Received SET_PAINT_GUN_OFFSET command.");
                     if (isMoving || isHoming) { // Prevent changes while moving
                        webSocket.sendTXT(num, "{\"status\":\"Busy\",\"message\":\"Cannot set paint offsets while machine is busy.\"}");
                    } else {
                        float newX, newY;
                        int parsed = sscanf(command.c_str() + strlen("SET_PAINT_GUN_OFFSET "), "%f %f", &newX, &newY);
                        if (parsed == 2) {
                            paintGunOffsetX_inch = newX;
                            paintGunOffsetY_inch = newY;
                            // Save to Preferences
                            preferences.begin("machineCfg", false);
                            preferences.putFloat("paintGunOffX", paintGunOffsetX_inch);
                            preferences.putFloat("paintGunOffY", paintGunOffsetY_inch);
                            preferences.end();
                            Serial.printf("[DEBUG] Set Paint Gun Offset to X: %.2f, Y: %.2f\n", paintGunOffsetX_inch, paintGunOffsetY_inch);
                            // Send confirmation with all settings
                            sendAllSettingsUpdate(num, "Paint Gun Offset updated.");
                        } else {
                            webSocket.sendTXT(num, "{\"status\":\"Error\",\"message\":\"Invalid SET_PAINT_GUN_OFFSET format. Use: SET_PAINT_GUN_OFFSET X Y\"}");
                        }
                    }
                } else if (command.startsWith("SET_PAINT_SIDE_SETTINGS ")) {
                    // Format: SET_PAINT_SIDE_SETTINGS sideIndex z pitch roll gun_orientation speed
                    Serial.println("WebSocket: Received SET_PAINT_SIDE_SETTINGS command.");
                    
                    // Parse command to extract parameters
                    String parts[6]; // Need 6 parts: sideIndex, z, pitch, roll, gunOrientation, speed
                    int partCount = 0;
                    int startPos = 23; // Skip "SET_PAINT_SIDE_SETTINGS "
                    
                    for (int i = 0; i < 6 && startPos < command.length(); i++) {
                        int spacePos = command.indexOf(' ', startPos);
                        if (spacePos == -1) {
                            // Last part
                            if (startPos < command.length()) {
                                parts[i] = command.substring(startPos);
                                partCount++;
                            }
                            break;
                        } else {
                            parts[i] = command.substring(startPos, spacePos);
                            startPos = spacePos + 1;
                            partCount++;
                        }
                    }
                    
                    if (partCount == 6) {
                        int sideIndex = parts[0].toInt();
                        float newZ = parts[1].toFloat();
                        int newPitch = parts[2].toInt();
                        int newRoll = parts[3].toInt();
                        int newGunOrientation = parts[4].toInt();
                        float newSpeed = parts[5].toFloat();
                        
                        // Validate parameters
                        if (sideIndex < 0 || sideIndex > 3) {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid side index\"}");
                            return;
                        }
                        
                        // Handle Z
                        if (newZ >= 0.0 && newZ <= 2.5) {
                            paintZHeight_inch[sideIndex] = newZ;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid Z height (must be between 0.0 and 2.5)\"}");
                            return;
                        }
                        
                        // Handle Pitch
                        if (newPitch >= 0 && newPitch <= 90) {
                            paintPitchAngle[sideIndex] = newPitch;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid pitch angle (must be between 0 and 90)\"}");
                            return;
                        }
                        
                        // Handle Roll
                        if (newRoll == 0 || newRoll == 90) {
                            paintRollAngle[sideIndex] = newRoll;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid roll angle (must be 0 or 90)\"}");
                            return;
                        }
                        
                        // Handle Gun Orientation
                        if (newGunOrientation == 0 || newGunOrientation == 90) {
                            paintGunOrientation[sideIndex] = newGunOrientation;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid gun orientation (must be 0 or 90)\"}");
                            return;
                        }
                        
                        // Handle Speed
                        if (newSpeed >= 5000.0 && newSpeed <= 25000.0) {
                            paintSpeed[sideIndex] = newSpeed;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid speed (must be between 5000 and 25000)\"}");
                            return;
                        }
                        
                        // Save to preferences
                        preferences.begin("paintSettings", false);
                        String keyZ = "paintZ_" + String(sideIndex);
                        String keyP = "paintP_" + String(sideIndex);
                        String keyR = "paintR_" + String(sideIndex);
                        String keyGO = "paintGO_" + String(sideIndex);
                        String keyS = "paintS_" + String(sideIndex);
                        
                        preferences.putFloat(keyZ.c_str(), paintZHeight_inch[sideIndex]);
                        preferences.putInt(keyP.c_str(), paintPitchAngle[sideIndex]);
                        preferences.putInt(keyR.c_str(), paintRollAngle[sideIndex]);
                        preferences.putInt(keyGO.c_str(), paintGunOrientation[sideIndex]);
                        preferences.putFloat(keyS.c_str(), paintSpeed[sideIndex]);
                        preferences.end();
                        
                        // Send response with updated values
                        char response[100];
                        sprintf(response, "{\"status\":\"Ready\", \"message\":\"Updated settings for side %d: Z=%.2f, P=%d, R=%d, GO=%d, S=%.1f\"}", 
                                sideIndex, paintZHeight_inch[sideIndex], paintPitchAngle[sideIndex], 
                                paintRollAngle[sideIndex], paintGunOrientation[sideIndex], paintSpeed[sideIndex]);
                        webSocket.broadcastTXT(response);
                        
                        // Also update all settings everywhere
                        sendAllSettingsUpdate(ALL_CLIENTS, "");
                    } else {
                        webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid SET_PAINT_SIDE_SETTINGS format\"}");
                    }
                } else if (command.startsWith("JOG ")) {
                    // Serial.println("WebSocket: Received JOG command.");
                    if (!inCalibrationMode) {
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Must be in calibration mode to jog.\"}");
                    } else if (isMoving || isHoming) {
                        webSocket.sendTXT(num, "{\"status\":\"Busy\", \"message\":\"Cannot jog while machine is moving.\"}");
                    } else {
                        char axis;
                        float distance_inch;
                        int parsed = sscanf(command.c_str() + strlen("JOG "), "%c %f", &axis, &distance_inch);
                        
                        if (parsed == 2) {
                            long current_steps = 0;
                            long jog_steps = 0;
                            FastAccelStepper* stepper_to_move = NULL;
                            float speed = 0, accel = 0;

                            if (axis == 'X' && stepper_x) {
                                stepper_to_move = stepper_x;
                                current_steps = stepper_x->getCurrentPosition();
                                jog_steps = (long)(distance_inch * STEPS_PER_INCH_XY);
                                speed = patternXSpeed;
                                accel = patternXAccel;
                            } else if (axis == 'Y' && stepper_y_left && stepper_y_right) { // Assuming both Y move together
                                stepper_to_move = stepper_y_left; // Use left for current pos, command both
                                current_steps = stepper_y_left->getCurrentPosition();
                                jog_steps = (long)(distance_inch * STEPS_PER_INCH_XY);
                                speed = patternYSpeed;
                                accel = patternYAccel;
                            } else {
                                Serial.printf("[ERROR] Invalid axis '%c' or stepper not available for JOG.\n", axis);
                                webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid axis for jog.\"}");
                            }

                            if (stepper_to_move) {
                                isMoving = true; // Set flag, loop() will handle completion
                                webSocket.broadcastTXT("{\"status\":\"Busy\", \"message\":\"Jogging...\"}");
                                
                                long target_steps = current_steps + jog_steps;
                                //Serial.printf("  Jogging %c by %.3f inches (%ld steps) from %ld to %ld\n", axis, distance_inch, jog_steps, current_steps, target_steps);

                                stepper_to_move->setSpeedInHz(speed);
                                stepper_to_move->setAcceleration(accel);
                                stepper_to_move->moveTo(target_steps);

                                if (axis == 'Y' && stepper_y_right) { // Command right Y too
                                    stepper_y_right->setSpeedInHz(speed);
                                    stepper_y_right->setAcceleration(accel);
                                    stepper_y_right->moveTo(target_steps);
                                }
                            }
                        } else {
                            Serial.println("[ERROR] Failed to parse JOG command.");
                            webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid JOG format. Use: JOG X/Y distance\"}");
                        }
                    }
                 } else if (command.startsWith("MOVE_TO_COORDS ")) {
                    Serial.println("WebSocket: Received MOVE_TO_COORDS command.");
                    if (!inCalibrationMode) {
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Must be in calibration mode to move to coordinates.\"}");
                    } else if (isMoving || isHoming) {
                        webSocket.sendTXT(num, "{\"status\":\"Busy\", \"message\":\"Cannot move while machine is busy.\"}");
                    } else {
                        float targetX_inch, targetY_inch;
                        int parsed = sscanf(command.c_str() + strlen("MOVE_TO_COORDS "), "%f %f", &targetX_inch, &targetY_inch);
                        
                        if (parsed == 2) {
                            // Validate coordinates (optional, add bounds checking if needed)
                            if (targetX_inch < 0 || targetY_inch < 0) {
                                webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid coordinates. Must be non-negative.\"}");
                                return;
                            }
                            
                            // Set up the move
                            isMoving = true; // Set flag, loop() will handle completion
                            webSocket.broadcastTXT("{\"status\":\"Busy\", \"message\":\"Moving to coordinates...\"}");
                            
                            // Convert to steps
                            long targetX_steps = (long)(targetX_inch * STEPS_PER_INCH_XY);
                            long targetY_steps = (long)(targetY_inch * STEPS_PER_INCH_XY);
                            
                            // Command the move
                            if (stepper_x) {
                                stepper_x->setSpeedInHz(patternXSpeed);
                                stepper_x->setAcceleration(patternXAccel);
                                stepper_x->moveTo(targetX_steps);
                            }
                            
                            if (stepper_y_left && stepper_y_right) {
                                stepper_y_left->setSpeedInHz(patternYSpeed);
                                stepper_y_left->setAcceleration(patternYAccel);
                                stepper_y_left->moveTo(targetY_steps);
                                
                                stepper_y_right->setSpeedInHz(patternYSpeed);
                                stepper_y_right->setAcceleration(patternYAccel);
                                stepper_y_right->moveTo(targetY_steps);
                            }
                        } else {
                            Serial.println("[ERROR] Failed to parse MOVE_TO_COORDS command.");
                            webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid format. Use: MOVE_TO_COORDS X Y\"}");
                         }
                     }
                 } else if (command.startsWith("SET_GRID_SPACING ")) { // UPDATED
                    Serial.println("[DEBUG] webSocketEvent: Handling SET_GRID_SPACING command."); // DEBUG
                    int newCols, newRows;
                    // Expecting "SET_GRID_SPACING C R"
                    int parsed = sscanf(command.c_str() + strlen("SET_GRID_SPACING "), "%d %d", &newCols, &newRows);
                    if (parsed == 2 && newCols > 0 && newRows > 0) {
                        // Call the new calculation function
                        calculateAndSetGridSpacing(newCols, newRows);
                    } else {
                        Serial.printf("[DEBUG] Failed to parse SET_GRID_SPACING command: %s\n", command.c_str());
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid SET_GRID_SPACING format. Use C R (integers > 0)\"}");
                    }
                 } else if (command.startsWith("SET_TRAY_SIZE ")) { // NEW
                    Serial.println("[DEBUG] webSocketEvent: Handling SET_TRAY_SIZE command."); // DEBUG
                    float newW, newH;
                    // Expecting "SET_TRAY_SIZE W H"
                    int parsed = sscanf(command.c_str() + strlen("SET_TRAY_SIZE "), "%f %f", &newW, &newH);
                    if (parsed == 2 && newW > 0 && newH > 0) {
                        Serial.printf("[DEBUG] New tray dimensions: width=%.2f, height=%.2f (old: width=%.2f, height=%.2f)\n", 
                                    newW, newH, trayWidth_inch, trayHeight_inch);
                        
                        // Save the new tray dimensions
                        trayWidth_inch = newW;
                        trayHeight_inch = newH;
                        
                        // Open preferences, save values, and close immediately
                        preferences.begin("machineCfg", false);
                        preferences.putFloat("trayWidth", trayWidth_inch);
                        preferences.putFloat("trayHeight", trayHeight_inch);
                        preferences.end();
                        
                        Serial.printf("[DEBUG] Set Tray Size to W=%.2f, H=%.2f\n", trayWidth_inch, trayHeight_inch);
                        
                        // Recalculate grid spacing with current grid dimensions to reflect new tray size
                        float oldGapX = placeGapX_inch;
                        float oldGapY = placeGapY_inch;
                        calculateAndSetGridSpacing(placeGridCols, placeGridRows);
                        
                        Serial.printf("[DEBUG] Gap values changed: X: %.3f  %.3f, Y: %.3f  %.3f\n", 
                                    oldGapX, placeGapX_inch, oldGapY, placeGapY_inch);
                        
                        // Instead of using a redundant call to sendAllSettingsUpdate, create a more specific message
                        // about the changes that were made
                        char msgBuffer[200];
                        sprintf(msgBuffer, "Tray Size updated to W=%.2f, H=%.2f. Gap recalculated: X=%.3f, Y=%.3f", 
                               trayWidth_inch, trayHeight_inch, placeGapX_inch, placeGapY_inch);
                        
                        // Send settings update to the specific client that requested the change
                        sendAllSettingsUpdate(num, msgBuffer);
                        // Also broadcast to all other clients
                        if (num != 255) {
                            sendAllSettingsUpdate(255, msgBuffer);
                        }
                    } else {
                        Serial.printf("[DEBUG] Failed to parse SET_TRAY_SIZE command: %s\n", command.c_str());
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid SET_TRAY_SIZE format.\"}");
                    }
                 } else if (command.startsWith("SET_PAINT_PATTERN_OFFSET ")) {
                    Serial.println("WebSocket: Received SET_PAINT_PATTERN_OFFSET command.");
                    if (isMoving || isHoming) { // Prevent changes while moving
                        webSocket.sendTXT(num, "{\"status\":\"Busy\",\"message\":\"Cannot set paint offsets while machine is busy.\"}");
                    } else {
                        float newX, newY;
                        int parsed = sscanf(command.c_str() + strlen("SET_PAINT_PATTERN_OFFSET "), "%f %f", &newX, &newY);
                        if (parsed == 2) {
                            paintPatternOffsetX_inch = newX;
                            paintPatternOffsetY_inch = newY;
                            // Save to Preferences
                            preferences.begin("machineCfg", false);
                            preferences.putFloat("paintPatOffX", paintPatternOffsetX_inch);
                            preferences.putFloat("paintPatOffY", paintPatternOffsetY_inch);
                            preferences.end();
                            Serial.printf("[DEBUG] Set Paint Pattern Offset to X: %.2f, Y: %.2f\n", paintPatternOffsetX_inch, paintPatternOffsetY_inch);
                            // Send confirmation with all settings
                            sendAllSettingsUpdate(num, "Paint Pattern Offset updated.");
                        } else {
                            webSocket.sendTXT(num, "{\"status\":\"Error\",\"message\":\"Invalid SET_PAINT_PATTERN_OFFSET format. Use: SET_PAINT_PATTERN_OFFSET X Y\"}");
                        }
                    }
                } else if (command.startsWith("SET_PAINT_GUN_OFFSET ")) {
                    Serial.println("WebSocket: Received SET_PAINT_GUN_OFFSET command.");
                     if (isMoving || isHoming) { // Prevent changes while moving
                        webSocket.sendTXT(num, "{\"status\":\"Busy\",\"message\":\"Cannot set paint offsets while machine is busy.\"}");
                    } else {
                        float newX, newY;
                        int parsed = sscanf(command.c_str() + strlen("SET_PAINT_GUN_OFFSET "), "%f %f", &newX, &newY);
                        if (parsed == 2) {
                            paintGunOffsetX_inch = newX;
                            paintGunOffsetY_inch = newY;
                            // Save to Preferences
                            preferences.begin("machineCfg", false);
                            preferences.putFloat("paintGunOffX", paintGunOffsetX_inch);
                            preferences.putFloat("paintGunOffY", paintGunOffsetY_inch);
                            preferences.end();
                            Serial.printf("[DEBUG] Set Paint Gun Offset to X: %.2f, Y: %.2f\n", paintGunOffsetX_inch, paintGunOffsetY_inch);
                            // Send confirmation with all settings
                            sendAllSettingsUpdate(num, "Paint Gun Offset updated.");
                        } else {
                            webSocket.sendTXT(num, "{\"status\":\"Error\",\"message\":\"Invalid SET_PAINT_GUN_OFFSET format. Use: SET_PAINT_GUN_OFFSET X Y\"}");
                        }
                    }
                } else if (command.startsWith("SET_PAINT_SIDE_SETTINGS ")) {
                    // Format: SET_PAINT_SIDE_SETTINGS sideIndex z pitch roll gun_orientation speed
                    Serial.println("WebSocket: Received SET_PAINT_SIDE_SETTINGS command.");
                    
                    // Parse command to extract parameters
                    String parts[6]; // Need 6 parts: sideIndex, z, pitch, roll, gunOrientation, speed
                    int partCount = 0;
                    int startPos = 23; // Skip "SET_PAINT_SIDE_SETTINGS "
                    
                    for (int i = 0; i < 6 && startPos < command.length(); i++) {
                        int spacePos = command.indexOf(' ', startPos);
                        if (spacePos == -1) {
                            // Last part
                            if (startPos < command.length()) {
                                parts[i] = command.substring(startPos);
                                partCount++;
                            }
                            break;
                        } else {
                            parts[i] = command.substring(startPos, spacePos);
                            startPos = spacePos + 1;
                            partCount++;
                        }
                    }
                    
                    if (partCount == 6) {
                        int sideIndex = parts[0].toInt();
                        float newZ = parts[1].toFloat();
                        int newPitch = parts[2].toInt();
                        int newRoll = parts[3].toInt();
                        int newGunOrientation = parts[4].toInt();
                        float newSpeed = parts[5].toFloat();
                        
                        // Validate parameters
                        if (sideIndex < 0 || sideIndex > 3) {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid side index\"}");
                            return;
                        }
                        
                        // Handle Z
                        if (newZ >= 0.0 && newZ <= 2.5) {
                            paintZHeight_inch[sideIndex] = newZ;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid Z height (must be between 0.0 and 2.5)\"}");
                            return;
                        }
                        
                        // Handle Pitch
                        if (newPitch >= 0 && newPitch <= 90) {
                            paintPitchAngle[sideIndex] = newPitch;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid pitch angle (must be between 0 and 90)\"}");
                            return;
                        }
                        
                        // Handle Roll
                        if (newRoll == 0 || newRoll == 90) {
                            paintRollAngle[sideIndex] = newRoll;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid roll angle (must be 0 or 90)\"}");
                            return;
                        }
                        
                        // Handle Gun Orientation
                        if (newGunOrientation == 0 || newGunOrientation == 90) {
                            paintGunOrientation[sideIndex] = newGunOrientation;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid gun orientation (must be 0 or 90)\"}");
                            return;
                        }
                        
                        // Handle Speed
                        if (newSpeed >= 5000.0 && newSpeed <= 25000.0) {
                            paintSpeed[sideIndex] = newSpeed;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid speed (must be between 5000 and 25000)\"}");
                            return;
                        }
                        
                        // Save to preferences
                        preferences.begin("paintSettings", false);
                        String keyZ = "paintZ_" + String(sideIndex);
                        String keyP = "paintP_" + String(sideIndex);
                        String keyR = "paintR_" + String(sideIndex);
                        String keyGO = "paintGO_" + String(sideIndex);
                        String keyS = "paintS_" + String(sideIndex);
                        
                        preferences.putFloat(keyZ.c_str(), paintZHeight_inch[sideIndex]);
                        preferences.putInt(keyP.c_str(), paintPitchAngle[sideIndex]);
                        preferences.putInt(keyR.c_str(), paintRollAngle[sideIndex]);
                        preferences.putInt(keyGO.c_str(), paintGunOrientation[sideIndex]);
                        preferences.putFloat(keyS.c_str(), paintSpeed[sideIndex]);
                        preferences.end();
                        
                        // Send response with updated values
                        char response[100];
                        sprintf(response, "{\"status\":\"Ready\", \"message\":\"Updated settings for side %d: Z=%.2f, P=%d, R=%d, GO=%d, S=%.1f\"}", 
                                sideIndex, paintZHeight_inch[sideIndex], paintPitchAngle[sideIndex], 
                                paintRollAngle[sideIndex], paintGunOrientation[sideIndex], paintSpeed[sideIndex]);
                        webSocket.broadcastTXT(response);
                        
                        // Also update all settings everywhere
                        sendAllSettingsUpdate(ALL_CLIENTS, "");
                    } else {
                        webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid SET_PAINT_SIDE_SETTINGS format\"}");
                    }
                } else if (command.startsWith("JOG ")) {
                    // Serial.println("WebSocket: Received JOG command.");
                    if (!inCalibrationMode) {
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Must be in calibration mode to jog.\"}");
                    } else if (isMoving || isHoming) {
                        webSocket.sendTXT(num, "{\"status\":\"Busy\", \"message\":\"Cannot jog while machine is moving.\"}");
                    } else {
                        char axis;
                        float distance_inch;
                        int parsed = sscanf(command.c_str() + strlen("JOG "), "%c %f", &axis, &distance_inch);
                        
                        if (parsed == 2) {
                            long current_steps = 0;
                            long jog_steps = 0;
                            FastAccelStepper* stepper_to_move = NULL;
                            float speed = 0, accel = 0;

                            if (axis == 'X' && stepper_x) {
                                stepper_to_move = stepper_x;
                                current_steps = stepper_x->getCurrentPosition();
                                jog_steps = (long)(distance_inch * STEPS_PER_INCH_XY);
                                speed = patternXSpeed;
                                accel = patternXAccel;
                            } else if (axis == 'Y' && stepper_y_left && stepper_y_right) { // Assuming both Y move together
                                stepper_to_move = stepper_y_left; // Use left for current pos, command both
                                current_steps = stepper_y_left->getCurrentPosition();
                                jog_steps = (long)(distance_inch * STEPS_PER_INCH_XY);
                                speed = patternYSpeed;
                                accel = patternYAccel;
                            } else {
                                Serial.printf("[ERROR] Invalid axis '%c' or stepper not available for JOG.\n", axis);
                                webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid axis for jog.\"}");
                            }

                            if (stepper_to_move) {
                                isMoving = true; // Set flag, loop() will handle completion
                                webSocket.broadcastTXT("{\"status\":\"Busy\", \"message\":\"Jogging...\"}");
                                
                                long target_steps = current_steps + jog_steps;
                                //Serial.printf("  Jogging %c by %.3f inches (%ld steps) from %ld to %ld\n", axis, distance_inch, jog_steps, current_steps, target_steps);

                                stepper_to_move->setSpeedInHz(speed);
                                stepper_to_move->setAcceleration(accel);
                                stepper_to_move->moveTo(target_steps);

                                if (axis == 'Y' && stepper_y_right) { // Command right Y too
                                    stepper_y_right->setSpeedInHz(speed);
                                    stepper_y_right->setAcceleration(accel);
                                    stepper_y_right->moveTo(target_steps);
                                }
                            }
                        } else {
                            Serial.println("[ERROR] Failed to parse JOG command.");
                            webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid JOG format. Use: JOG X/Y distance\"}");
                        }
                    }
                 } else if (command.startsWith("MOVE_TO_COORDS ")) {
                    Serial.println("WebSocket: Received MOVE_TO_COORDS command.");
                    if (!inCalibrationMode) {
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Must be in calibration mode to move to coordinates.\"}");
                    } else if (isMoving || isHoming) {
                        webSocket.sendTXT(num, "{\"status\":\"Busy\", \"message\":\"Cannot move while machine is busy.\"}");
                    } else {
                        float targetX_inch, targetY_inch;
                        int parsed = sscanf(command.c_str() + strlen("MOVE_TO_COORDS "), "%f %f", &targetX_inch, &targetY_inch);
                        
                        if (parsed == 2) {
                            // Validate coordinates (optional, add bounds checking if needed)
                            if (targetX_inch < 0 || targetY_inch < 0) {
                                webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid coordinates. Must be non-negative.\"}");
                                return;
                            }
                            
                            // Set up the move
                            isMoving = true; // Set flag, loop() will handle completion
                            webSocket.broadcastTXT("{\"status\":\"Busy\", \"message\":\"Moving to coordinates...\"}");
                            
                            // Convert to steps
                            long targetX_steps = (long)(targetX_inch * STEPS_PER_INCH_XY);
                            long targetY_steps = (long)(targetY_inch * STEPS_PER_INCH_XY);
                            
                            // Command the move
                            if (stepper_x) {
                                stepper_x->setSpeedInHz(patternXSpeed);
                                stepper_x->setAcceleration(patternXAccel);
                                stepper_x->moveTo(targetX_steps);
                            }
                            
                            if (stepper_y_left && stepper_y_right) {
                                stepper_y_left->setSpeedInHz(patternYSpeed);
                                stepper_y_left->setAcceleration(patternYAccel);
                                stepper_y_left->moveTo(targetY_steps);
                                
                                stepper_y_right->setSpeedInHz(patternYSpeed);
                                stepper_y_right->setAcceleration(patternYAccel);
                                stepper_y_right->moveTo(targetY_steps);
                            }
                        } else {
                            Serial.println("[ERROR] Failed to parse MOVE_TO_COORDS command.");
                            webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid format. Use: MOVE_TO_COORDS X Y\"}");
                         }
                     }
                 } else if (command.startsWith("SET_GRID_SPACING ")) { // UPDATED
                    Serial.println("[DEBUG] webSocketEvent: Handling SET_GRID_SPACING command."); // DEBUG
                    int newCols, newRows;
                    // Expecting "SET_GRID_SPACING C R"
                    int parsed = sscanf(command.c_str() + strlen("SET_GRID_SPACING "), "%d %d", &newCols, &newRows);
                    if (parsed == 2 && newCols > 0 && newRows > 0) {
                        // Call the new calculation function
                        calculateAndSetGridSpacing(newCols, newRows);
                    } else {
                        Serial.printf("[DEBUG] Failed to parse SET_GRID_SPACING command: %s\n", command.c_str());
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid SET_GRID_SPACING format. Use C R (integers > 0)\"}");
                    }
                 } else if (command.startsWith("SET_TRAY_SIZE ")) { // NEW
                    Serial.println("[DEBUG] webSocketEvent: Handling SET_TRAY_SIZE command."); // DEBUG
                    float newW, newH;
                    // Expecting "SET_TRAY_SIZE W H"
                    int parsed = sscanf(command.c_str() + strlen("SET_TRAY_SIZE "), "%f %f", &newW, &newH);
                    if (parsed == 2 && newW > 0 && newH > 0) {
                        Serial.printf("[DEBUG] New tray dimensions: width=%.2f, height=%.2f (old: width=%.2f, height=%.2f)\n", 
                                    newW, newH, trayWidth_inch, trayHeight_inch);
                        
                        // Save the new tray dimensions
                        trayWidth_inch = newW;
                        trayHeight_inch = newH;
                        
                        // Open preferences, save values, and close immediately
                        preferences.begin("machineCfg", false);
                        preferences.putFloat("trayWidth", trayWidth_inch);
                        preferences.putFloat("trayHeight", trayHeight_inch);
                        preferences.end();
                        
                        Serial.printf("[DEBUG] Set Tray Size to W=%.2f, H=%.2f\n", trayWidth_inch, trayHeight_inch);
                        
                        // Recalculate grid spacing with current grid dimensions to reflect new tray size
                        float oldGapX = placeGapX_inch;
                        float oldGapY = placeGapY_inch;
                        calculateAndSetGridSpacing(placeGridCols, placeGridRows);
                        
                        Serial.printf("[DEBUG] Gap values changed: X: %.3f  %.3f, Y: %.3f  %.3f\n", 
                                    oldGapX, placeGapX_inch, oldGapY, placeGapY_inch);
                        
                        // Instead of using a redundant call to sendAllSettingsUpdate, create a more specific message
                        // about the changes that were made
                        char msgBuffer[200];
                        sprintf(msgBuffer, "Tray Size updated to W=%.2f, H=%.2f. Gap recalculated: X=%.3f, Y=%.3f", 
                               trayWidth_inch, trayHeight_inch, placeGapX_inch, placeGapY_inch);
                        
                        // Send settings update to the specific client that requested the change
                        sendAllSettingsUpdate(num, msgBuffer);
                        // Also broadcast to all other clients
                        if (num != 255) {
                            sendAllSettingsUpdate(255, msgBuffer);
                        }
                    } else {
                        Serial.printf("[DEBUG] Failed to parse SET_TRAY_SIZE command: %s\n", command.c_str());
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid SET_TRAY_SIZE format.\"}");
                    }
                 } else if (command.startsWith("SET_PAINT_PATTERN_OFFSET ")) {
                    Serial.println("WebSocket: Received SET_PAINT_PATTERN_OFFSET command.");
                    if (isMoving || isHoming) { // Prevent changes while moving
                        webSocket.sendTXT(num, "{\"status\":\"Busy\",\"message\":\"Cannot set paint offsets while machine is busy.\"}");
                    } else {
                        float newX, newY;
                        int parsed = sscanf(command.c_str() + strlen("SET_PAINT_PATTERN_OFFSET "), "%f %f", &newX, &newY);
                        if (parsed == 2) {
                            paintPatternOffsetX_inch = newX;
                            paintPatternOffsetY_inch = newY;
                            // Save to Preferences
                            preferences.begin("machineCfg", false);
                            preferences.putFloat("paintPatOffX", paintPatternOffsetX_inch);
                            preferences.putFloat("paintPatOffY", paintPatternOffsetY_inch);
                            preferences.end();
                            Serial.printf("[DEBUG] Set Paint Pattern Offset to X: %.2f, Y: %.2f\n", paintPatternOffsetX_inch, paintPatternOffsetY_inch);
                            // Send confirmation with all settings
                            sendAllSettingsUpdate(num, "Paint Pattern Offset updated.");
                        } else {
                            webSocket.sendTXT(num, "{\"status\":\"Error\",\"message\":\"Invalid SET_PAINT_PATTERN_OFFSET format. Use: SET_PAINT_PATTERN_OFFSET X Y\"}");
                        }
                    }
                } else if (command.startsWith("SET_PAINT_GUN_OFFSET ")) {
                    Serial.println("WebSocket: Received SET_PAINT_GUN_OFFSET command.");
                     if (isMoving || isHoming) { // Prevent changes while moving
                        webSocket.sendTXT(num, "{\"status\":\"Busy\",\"message\":\"Cannot set paint offsets while machine is busy.\"}");
                    } else {
                        float newX, newY;
                        int parsed = sscanf(command.c_str() + strlen("SET_PAINT_GUN_OFFSET "), "%f %f", &newX, &newY);
                        if (parsed == 2) {
                            paintGunOffsetX_inch = newX;
                            paintGunOffsetY_inch = newY;
                            // Save to Preferences
                            preferences.begin("machineCfg", false);
                            preferences.putFloat("paintGunOffX", paintGunOffsetX_inch);
                            preferences.putFloat("paintGunOffY", paintGunOffsetY_inch);
                            preferences.end();
                            Serial.printf("[DEBUG] Set Paint Gun Offset to X: %.2f, Y: %.2f\n", paintGunOffsetX_inch, paintGunOffsetY_inch);
                            // Send confirmation with all settings
                            sendAllSettingsUpdate(num, "Paint Gun Offset updated.");
                        } else {
                            webSocket.sendTXT(num, "{\"status\":\"Error\",\"message\":\"Invalid SET_PAINT_GUN_OFFSET format. Use: SET_PAINT_GUN_OFFSET X Y\"}");
                        }
                    }
                } else if (command.startsWith("SET_PAINT_SIDE_SETTINGS ")) {
                    // Format: SET_PAINT_SIDE_SETTINGS sideIndex z pitch roll gun_orientation speed
                    Serial.println("WebSocket: Received SET_PAINT_SIDE_SETTINGS command.");
                    
                    // Parse command to extract parameters
                    String parts[6]; // Need 6 parts: sideIndex, z, pitch, roll, gunOrientation, speed
                    int partCount = 0;
                    int startPos = 23; // Skip "SET_PAINT_SIDE_SETTINGS "
                    
                    for (int i = 0; i < 6 && startPos < command.length(); i++) {
                        int spacePos = command.indexOf(' ', startPos);
                        if (spacePos == -1) {
                            // Last part
                            if (startPos < command.length()) {
                                parts[i] = command.substring(startPos);
                                partCount++;
                            }
                            break;
                        } else {
                            parts[i] = command.substring(startPos, spacePos);
                            startPos = spacePos + 1;
                            partCount++;
                        }
                    }
                    
                    if (partCount == 6) {
                        int sideIndex = parts[0].toInt();
                        float newZ = parts[1].toFloat();
                        int newPitch = parts[2].toInt();
                        int newRoll = parts[3].toInt();
                        int newGunOrientation = parts[4].toInt();
                        float newSpeed = parts[5].toFloat();
                        
                        // Validate parameters
                        if (sideIndex < 0 || sideIndex > 3) {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid side index\"}");
                            return;
                        }
                        
                        // Handle Z
                        if (newZ >= 0.0 && newZ <= 2.5) {
                            paintZHeight_inch[sideIndex] = newZ;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid Z height (must be between 0.0 and 2.5)\"}");
                            return;
                        }
                        
                        // Handle Pitch
                        if (newPitch >= 0 && newPitch <= 90) {
                            paintPitchAngle[sideIndex] = newPitch;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid pitch angle (must be between 0 and 90)\"}");
                            return;
                        }
                        
                        // Handle Roll
                        if (newRoll == 0 || newRoll == 90) {
                            paintRollAngle[sideIndex] = newRoll;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid roll angle (must be 0 or 90)\"}");
                            return;
                        }
                        
                        // Handle Gun Orientation
                        if (newGunOrientation == 0 || newGunOrientation == 90) {
                            paintGunOrientation[sideIndex] = newGunOrientation;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid gun orientation (must be 0 or 90)\"}");
                            return;
                        }
                        
                        // Handle Speed
                        if (newSpeed >= 5000.0 && newSpeed <= 25000.0) {
                            paintSpeed[sideIndex] = newSpeed;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid speed (must be between 5000 and 25000)\"}");
                            return;
                        }
                        
                        // Save to preferences
                        preferences.begin("paintSettings", false);
                        String keyZ = "paintZ_" + String(sideIndex);
                        String keyP = "paintP_" + String(sideIndex);
                        String keyR = "paintR_" + String(sideIndex);
                        String keyGO = "paintGO_" + String(sideIndex);
                        String keyS = "paintS_" + String(sideIndex);
                        
                        preferences.putFloat(keyZ.c_str(), paintZHeight_inch[sideIndex]);
                        preferences.putInt(keyP.c_str(), paintPitchAngle[sideIndex]);
                        preferences.putInt(keyR.c_str(), paintRollAngle[sideIndex]);
                        preferences.putInt(keyGO.c_str(), paintGunOrientation[sideIndex]);
                        preferences.putFloat(keyS.c_str(), paintSpeed[sideIndex]);
                        preferences.end();
                        
                        // Send response with updated values
                        char response[100];
                        sprintf(response, "{\"status\":\"Ready\", \"message\":\"Updated settings for side %d: Z=%.2f, P=%d, R=%d, GO=%d, S=%.1f\"}", 
                                sideIndex, paintZHeight_inch[sideIndex], paintPitchAngle[sideIndex], 
                                paintRollAngle[sideIndex], paintGunOrientation[sideIndex], paintSpeed[sideIndex]);
                        webSocket.broadcastTXT(response);
                        
                        // Also update all settings everywhere
                        sendAllSettingsUpdate(ALL_CLIENTS, "");
                    } else {
                        webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid SET_PAINT_SIDE_SETTINGS format\"}");
                    }
                } else if (command.startsWith("JOG ")) {
                    // Serial.println("WebSocket: Received JOG command.");
                    if (!inCalibrationMode) {
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Must be in calibration mode to jog.\"}");
                    } else if (isMoving || isHoming) {
                        webSocket.sendTXT(num, "{\"status\":\"Busy\", \"message\":\"Cannot jog while machine is moving.\"}");
                    } else {
                        char axis;
                        float distance_inch;
                        int parsed = sscanf(command.c_str() + strlen("JOG "), "%c %f", &axis, &distance_inch);
                        
                        if (parsed == 2) {
                            long current_steps = 0;
                            long jog_steps = 0;
                            FastAccelStepper* stepper_to_move = NULL;
                            float speed = 0, accel = 0;

                            if (axis == 'X' && stepper_x) {
                                stepper_to_move = stepper_x;
                                current_steps = stepper_x->getCurrentPosition();
                                jog_steps = (long)(distance_inch * STEPS_PER_INCH_XY);
                                speed = patternXSpeed;
                                accel = patternXAccel;
                            } else if (axis == 'Y' && stepper_y_left && stepper_y_right) { // Assuming both Y move together
                                stepper_to_move = stepper_y_left; // Use left for current pos, command both
                                current_steps = stepper_y_left->getCurrentPosition();
                                jog_steps = (long)(distance_inch * STEPS_PER_INCH_XY);
                                speed = patternYSpeed;
                                accel = patternYAccel;
                            } else {
                                Serial.printf("[ERROR] Invalid axis '%c' or stepper not available for JOG.\n", axis);
                                webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid axis for jog.\"}");
                            }

                            if (stepper_to_move) {
                                isMoving = true; // Set flag, loop() will handle completion
                                webSocket.broadcastTXT("{\"status\":\"Busy\", \"message\":\"Jogging...\"}");
                                
                                long target_steps = current_steps + jog_steps;
                                //Serial.printf("  Jogging %c by %.3f inches (%ld steps) from %ld to %ld\n", axis, distance_inch, jog_steps, current_steps, target_steps);

                                stepper_to_move->setSpeedInHz(speed);
                                stepper_to_move->setAcceleration(accel);
                                stepper_to_move->moveTo(target_steps);

                                if (axis == 'Y' && stepper_y_right) { // Command right Y too
                                    stepper_y_right->setSpeedInHz(speed);
                                    stepper_y_right->setAcceleration(accel);
                                    stepper_y_right->moveTo(target_steps);
                                }
                            }
                        } else {
                            Serial.println("[ERROR] Failed to parse JOG command.");
                            webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid JOG format. Use: JOG X/Y distance\"}");
                        }
                    }
                 } else if (command.startsWith("MOVE_TO_COORDS ")) {
                    Serial.println("WebSocket: Received MOVE_TO_COORDS command.");
                    if (!inCalibrationMode) {
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Must be in calibration mode to move to coordinates.\"}");
                    } else if (isMoving || isHoming) {
                        webSocket.sendTXT(num, "{\"status\":\"Busy\", \"message\":\"Cannot move while machine is busy.\"}");
                    } else {
                        float targetX_inch, targetY_inch;
                        int parsed = sscanf(command.c_str() + strlen("MOVE_TO_COORDS "), "%f %f", &targetX_inch, &targetY_inch);
                        
                        if (parsed == 2) {
                            // Validate coordinates (optional, add bounds checking if needed)
                            if (targetX_inch < 0 || targetY_inch < 0) {
                                webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid coordinates. Must be non-negative.\"}");
                                return;
                            }
                            
                            // Set up the move
                            isMoving = true; // Set flag, loop() will handle completion
                            webSocket.broadcastTXT("{\"status\":\"Busy\", \"message\":\"Moving to coordinates...\"}");
                            
                            // Convert to steps
                            long targetX_steps = (long)(targetX_inch * STEPS_PER_INCH_XY);
                            long targetY_steps = (long)(targetY_inch * STEPS_PER_INCH_XY);
                            
                            // Command the move
                            if (stepper_x) {
                                stepper_x->setSpeedInHz(patternXSpeed);
                                stepper_x->setAcceleration(patternXAccel);
                                stepper_x->moveTo(targetX_steps);
                            }
                            
                            if (stepper_y_left && stepper_y_right) {
                                stepper_y_left->setSpeedInHz(patternYSpeed);
                                stepper_y_left->setAcceleration(patternYAccel);
                                stepper_y_left->moveTo(targetY_steps);
                                
                                stepper_y_right->setSpeedInHz(patternYSpeed);
                                stepper_y_right->setAcceleration(patternYAccel);
                                stepper_y_right->moveTo(targetY_steps);
                            }
                        } else {
                            Serial.println("[ERROR] Failed to parse MOVE_TO_COORDS command.");
                            webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid format. Use: MOVE_TO_COORDS X Y\"}");
                         }
                     }
                 } else if (command.startsWith("SET_GRID_SPACING ")) { // UPDATED
                    Serial.println("[DEBUG] webSocketEvent: Handling SET_GRID_SPACING command."); // DEBUG
                    int newCols, newRows;
                    // Expecting "SET_GRID_SPACING C R"
                    int parsed = sscanf(command.c_str() + strlen("SET_GRID_SPACING "), "%d %d", &newCols, &newRows);
                    if (parsed == 2 && newCols > 0 && newRows > 0) {
                        // Call the new calculation function
                        calculateAndSetGridSpacing(newCols, newRows);
                    } else {
                        Serial.printf("[DEBUG] Failed to parse SET_GRID_SPACING command: %s\n", command.c_str());
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid SET_GRID_SPACING format. Use C R (integers > 0)\"}");
                    }
                 } else if (command.startsWith("SET_TRAY_SIZE ")) { // NEW
                    Serial.println("[DEBUG] webSocketEvent: Handling SET_TRAY_SIZE command."); // DEBUG
                    float newW, newH;
                    // Expecting "SET_TRAY_SIZE W H"
                    int parsed = sscanf(command.c_str() + strlen("SET_TRAY_SIZE "), "%f %f", &newW, &newH);
                    if (parsed == 2 && newW > 0 && newH > 0) {
                        Serial.printf("[DEBUG] New tray dimensions: width=%.2f, height=%.2f (old: width=%.2f, height=%.2f)\n", 
                                    newW, newH, trayWidth_inch, trayHeight_inch);
                        
                        // Save the new tray dimensions
                        trayWidth_inch = newW;
                        trayHeight_inch = newH;
                        
                        // Open preferences, save values, and close immediately
                        preferences.begin("machineCfg", false);
                        preferences.putFloat("trayWidth", trayWidth_inch);
                        preferences.putFloat("trayHeight", trayHeight_inch);
                        preferences.end();
                        
                        Serial.printf("[DEBUG] Set Tray Size to W=%.2f, H=%.2f\n", trayWidth_inch, trayHeight_inch);
                        
                        // Recalculate grid spacing with current grid dimensions to reflect new tray size
                        float oldGapX = placeGapX_inch;
                        float oldGapY = placeGapY_inch;
                        calculateAndSetGridSpacing(placeGridCols, placeGridRows);
                        
                        Serial.printf("[DEBUG] Gap values changed: X: %.3f  %.3f, Y: %.3f  %.3f\n", 
                                    oldGapX, placeGapX_inch, oldGapY, placeGapY_inch);
                        
                        // Instead of using a redundant call to sendAllSettingsUpdate, create a more specific message
                        // about the changes that were made
                        char msgBuffer[200];
                        sprintf(msgBuffer, "Tray Size updated to W=%.2f, H=%.2f. Gap recalculated: X=%.3f, Y=%.3f", 
                               trayWidth_inch, trayHeight_inch, placeGapX_inch, placeGapY_inch);
                        
                        // Send settings update to the specific client that requested the change
                        sendAllSettingsUpdate(num, msgBuffer);
                        // Also broadcast to all other clients
                        if (num != 255) {
                            sendAllSettingsUpdate(255, msgBuffer);
                        }
                    } else {
                        Serial.printf("[DEBUG] Failed to parse SET_TRAY_SIZE command: %s\n", command.c_str());
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid SET_TRAY_SIZE format.\"}");
                    }
                 } else if (command.startsWith("SET_PAINT_PATTERN_OFFSET ")) {
                    Serial.println("WebSocket: Received SET_PAINT_PATTERN_OFFSET command.");
                    if (isMoving || isHoming) { // Prevent changes while moving
                        webSocket.sendTXT(num, "{\"status\":\"Busy\",\"message\":\"Cannot set paint offsets while machine is busy.\"}");
                    } else {
                        float newX, newY;
                        int parsed = sscanf(command.c_str() + strlen("SET_PAINT_PATTERN_OFFSET "), "%f %f", &newX, &newY);
                        if (parsed == 2) {
                            paintPatternOffsetX_inch = newX;
                            paintPatternOffsetY_inch = newY;
                            // Save to Preferences
                            preferences.begin("machineCfg", false);
                            preferences.putFloat("paintPatOffX", paintPatternOffsetX_inch);
                            preferences.putFloat("paintPatOffY", paintPatternOffsetY_inch);
                            preferences.end();
                            Serial.printf("[DEBUG] Set Paint Pattern Offset to X: %.2f, Y: %.2f\n", paintPatternOffsetX_inch, paintPatternOffsetY_inch);
                            // Send confirmation with all settings
                            sendAllSettingsUpdate(num, "Paint Pattern Offset updated.");
                        } else {
                            webSocket.sendTXT(num, "{\"status\":\"Error\",\"message\":\"Invalid SET_PAINT_PATTERN_OFFSET format. Use: SET_PAINT_PATTERN_OFFSET X Y\"}");
                        }
                    }
                } else if (command.startsWith("SET_PAINT_GUN_OFFSET ")) {
                    Serial.println("WebSocket: Received SET_PAINT_GUN_OFFSET command.");
                     if (isMoving || isHoming) { // Prevent changes while moving
                        webSocket.sendTXT(num, "{\"status\":\"Busy\",\"message\":\"Cannot set paint offsets while machine is busy.\"}");
                    } else {
                        float newX, newY;
                        int parsed = sscanf(command.c_str() + strlen("SET_PAINT_GUN_OFFSET "), "%f %f", &newX, &newY);
                        if (parsed == 2) {
                            paintGunOffsetX_inch = newX;
                            paintGunOffsetY_inch = newY;
                            // Save to Preferences
                            preferences.begin("machineCfg", false);
                            preferences.putFloat("paintGunOffX", paintGunOffsetX_inch);
                            preferences.putFloat("paintGunOffY", paintGunOffsetY_inch);
                            preferences.end();
                            Serial.printf("[DEBUG] Set Paint Gun Offset to X: %.2f, Y: %.2f\n", paintGunOffsetX_inch, paintGunOffsetY_inch);
                            // Send confirmation with all settings
                            sendAllSettingsUpdate(num, "Paint Gun Offset updated.");
                        } else {
                            webSocket.sendTXT(num, "{\"status\":\"Error\",\"message\":\"Invalid SET_PAINT_GUN_OFFSET format. Use: SET_PAINT_GUN_OFFSET X Y\"}");
                        }
                    }
                } else if (command.startsWith("SET_PAINT_SIDE_SETTINGS ")) {
                    // Format: SET_PAINT_SIDE_SETTINGS sideIndex z pitch roll gun_orientation speed
                    Serial.println("WebSocket: Received SET_PAINT_SIDE_SETTINGS command.");
                    
                    // Parse command to extract parameters
                    String parts[6]; // Need 6 parts: sideIndex, z, pitch, roll, gunOrientation, speed
                    int partCount = 0;
                    int startPos = 23; // Skip "SET_PAINT_SIDE_SETTINGS "
                    
                    for (int i = 0; i < 6 && startPos < command.length(); i++) {
                        int spacePos = command.indexOf(' ', startPos);
                        if (spacePos == -1) {
                            // Last part
                            if (startPos < command.length()) {
                                parts[i] = command.substring(startPos);
                                partCount++;
                            }
                            break;
                        } else {
                            parts[i] = command.substring(startPos, spacePos);
                            startPos = spacePos + 1;
                            partCount++;
                        }
                    }
                    
                    if (partCount == 6) {
                        int sideIndex = parts[0].toInt();
                        float newZ = parts[1].toFloat();
                        int newPitch = parts[2].toInt();
                        int newRoll = parts[3].toInt();
                        int newGunOrientation = parts[4].toInt();
                        float newSpeed = parts[5].toFloat();
                        
                        // Validate parameters
                        if (sideIndex < 0 || sideIndex > 3) {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid side index\"}");
                            return;
                        }
                        
                        // Handle Z
                        if (newZ >= 0.0 && newZ <= 2.5) {
                            paintZHeight_inch[sideIndex] = newZ;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid Z height (must be between 0.0 and 2.5)\"}");
                            return;
                        }
                        
                        // Handle Pitch
                        if (newPitch >= 0 && newPitch <= 90) {
                            paintPitchAngle[sideIndex] = newPitch;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid pitch angle (must be between 0 and 90)\"}");
                            return;
                        }
                        
                        // Handle Roll
                        if (newRoll == 0 || newRoll == 90) {
                            paintRollAngle[sideIndex] = newRoll;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid roll angle (must be 0 or 90)\"}");
                            return;
                        }
                        
                        // Handle Gun Orientation
                        if (newGunOrientation == 0 || newGunOrientation == 90) {
                            paintGunOrientation[sideIndex] = newGunOrientation;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid gun orientation (must be 0 or 90)\"}");
                            return;
                        }
                        
                        // Handle Speed
                        if (newSpeed >= 5000.0 && newSpeed <= 25000.0) {
                            paintSpeed[sideIndex] = newSpeed;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid speed (must be between 5000 and 25000)\"}");
                            return;
                        }
                        
                        // Save to preferences
                        preferences.begin("paintSettings", false);
                        String keyZ = "paintZ_" + String(sideIndex);
                        String keyP = "paintP_" + String(sideIndex);
                        String keyR = "paintR_" + String(sideIndex);
                        String keyGO = "paintGO_" + String(sideIndex);
                        String keyS = "paintS_" + String(sideIndex);
                        
                        preferences.putFloat(keyZ.c_str(), paintZHeight_inch[sideIndex]);
                        preferences.putInt(keyP.c_str(), paintPitchAngle[sideIndex]);
                        preferences.putInt(keyR.c_str(), paintRollAngle[sideIndex]);
                        preferences.putInt(keyGO.c_str(), paintGunOrientation[sideIndex]);
                        preferences.putFloat(keyS.c_str(), paintSpeed[sideIndex]);
                        preferences.end();
                        
                        // Send response with updated values
                        char response[100];
                        sprintf(response, "{\"status\":\"Ready\", \"message\":\"Updated settings for side %d: Z=%.2f, P=%d, R=%d, GO=%d, S=%.1f\"}", 
                                sideIndex, paintZHeight_inch[sideIndex], paintPitchAngle[sideIndex], 
                                paintRollAngle[sideIndex], paintGunOrientation[sideIndex], paintSpeed[sideIndex]);
                        webSocket.broadcastTXT(response);
                        
                        // Also update all settings everywhere
                        sendAllSettingsUpdate(ALL_CLIENTS, "");
                    } else {
                        webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid SET_PAINT_SIDE_SETTINGS format\"}");
                    }
                } else if (command.startsWith("JOG ")) {
                    // Serial.println("WebSocket: Received JOG command.");
                    if (!inCalibrationMode) {
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Must be in calibration mode to jog.\"}");
                    } else if (isMoving || isHoming) {
                        webSocket.sendTXT(num, "{\"status\":\"Busy\", \"message\":\"Cannot jog while machine is moving.\"}");
                    } else {
                        char axis;
                        float distance_inch;
                        int parsed = sscanf(command.c_str() + strlen("JOG "), "%c %f", &axis, &distance_inch);
                        
                        if (parsed == 2) {
                            long current_steps = 0;
                            long jog_steps = 0;
                            FastAccelStepper* stepper_to_move = NULL;
                            float speed = 0, accel = 0;

                            if (axis == 'X' && stepper_x) {
                                stepper_to_move = stepper_x;
                                current_steps = stepper_x->getCurrentPosition();
                                jog_steps = (long)(distance_inch * STEPS_PER_INCH_XY);
                                speed = patternXSpeed;
                                accel = patternXAccel;
                            } else if (axis == 'Y' && stepper_y_left && stepper_y_right) { // Assuming both Y move together
                                stepper_to_move = stepper_y_left; // Use left for current pos, command both
                                current_steps = stepper_y_left->getCurrentPosition();
                                jog_steps = (long)(distance_inch * STEPS_PER_INCH_XY);
                                speed = patternYSpeed;
                                accel = patternYAccel;
                            } else {
                                Serial.printf("[ERROR] Invalid axis '%c' or stepper not available for JOG.\n", axis);
                                webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid axis for jog.\"}");
                            }

                            if (stepper_to_move) {
                                isMoving = true; // Set flag, loop() will handle completion
                                webSocket.broadcastTXT("{\"status\":\"Busy\", \"message\":\"Jogging...\"}");
                                
                                long target_steps = current_steps + jog_steps;
                                //Serial.printf("  Jogging %c by %.3f inches (%ld steps) from %ld to %ld\n", axis, distance_inch, jog_steps, current_steps, target_steps);

                                stepper_to_move->setSpeedInHz(speed);
                                stepper_to_move->setAcceleration(accel);
                                stepper_to_move->moveTo(target_steps);

                                if (axis == 'Y' && stepper_y_right) { // Command right Y too
                                    stepper_y_right->setSpeedInHz(speed);
                                    stepper_y_right->setAcceleration(accel);
                                    stepper_y_right->moveTo(target_steps);
                                }
                            }
                        } else {
                            Serial.println("[ERROR] Failed to parse JOG command.");
                            webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid JOG format. Use: JOG X/Y distance\"}");
                        }
                    }
                 } else if (command.startsWith("MOVE_TO_COORDS ")) {
                    Serial.println("WebSocket: Received MOVE_TO_COORDS command.");
                    if (!inCalibrationMode) {
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Must be in calibration mode to move to coordinates.\"}");
                    } else if (isMoving || isHoming) {
                        webSocket.sendTXT(num, "{\"status\":\"Busy\", \"message\":\"Cannot move while machine is busy.\"}");
                    } else {
                        float targetX_inch, targetY_inch;
                        int parsed = sscanf(command.c_str() + strlen("MOVE_TO_COORDS "), "%f %f", &targetX_inch, &targetY_inch);
                        
                        if (parsed == 2) {
                            // Validate coordinates (optional, add bounds checking if needed)
                            if (targetX_inch < 0 || targetY_inch < 0) {
                                webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid coordinates. Must be non-negative.\"}");
                                return;
                            }
                            
                            // Set up the move
                            isMoving = true; // Set flag, loop() will handle completion
                            webSocket.broadcastTXT("{\"status\":\"Busy\", \"message\":\"Moving to coordinates...\"}");
                            
                            // Convert to steps
                            long targetX_steps = (long)(targetX_inch * STEPS_PER_INCH_XY);
                            long targetY_steps = (long)(targetY_inch * STEPS_PER_INCH_XY);
                            
                            // Command the move
                            if (stepper_x) {
                                stepper_x->setSpeedInHz(patternXSpeed);
                                stepper_x->setAcceleration(patternXAccel);
                                stepper_x->moveTo(targetX_steps);
                            }
                            
                            if (stepper_y_left && stepper_y_right) {
                                stepper_y_left->setSpeedInHz(patternYSpeed);
                                stepper_y_left->setAcceleration(patternYAccel);
                                stepper_y_left->moveTo(targetY_steps);
                                
                                stepper_y_right->setSpeedInHz(patternYSpeed);
                                stepper_y_right->setAcceleration(patternYAccel);
                                stepper_y_right->moveTo(targetY_steps);
                            }
                        } else {
                            Serial.println("[ERROR] Failed to parse MOVE_TO_COORDS command.");
                            webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid format. Use: MOVE_TO_COORDS X Y\"}");
                         }
                     }
                 } else if (command.startsWith("SET_GRID_SPACING ")) { // UPDATED
                    Serial.println("[DEBUG] webSocketEvent: Handling SET_GRID_SPACING command."); // DEBUG
                    int newCols, newRows;
                    // Expecting "SET_GRID_SPACING C R"
                    int parsed = sscanf(command.c_str() + strlen("SET_GRID_SPACING "), "%d %d", &newCols, &newRows);
                    if (parsed == 2 && newCols > 0 && newRows > 0) {
                        // Call the new calculation function
                        calculateAndSetGridSpacing(newCols, newRows);
                    } else {
                        Serial.printf("[DEBUG] Failed to parse SET_GRID_SPACING command: %s\n", command.c_str());
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid SET_GRID_SPACING format. Use C R (integers > 0)\"}");
                    }
                 } else if (command.startsWith("SET_TRAY_SIZE ")) { // NEW
                    Serial.println("[DEBUG] webSocketEvent: Handling SET_TRAY_SIZE command."); // DEBUG
                    float newW, newH;
                    // Expecting "SET_TRAY_SIZE W H"
                    int parsed = sscanf(command.c_str() + strlen("SET_TRAY_SIZE "), "%f %f", &newW, &newH);
                    if (parsed == 2 && newW > 0 && newH > 0) {
                        Serial.printf("[DEBUG] New tray dimensions: width=%.2f, height=%.2f (old: width=%.2f, height=%.2f)\n", 
                                    newW, newH, trayWidth_inch, trayHeight_inch);
                        
                        // Save the new tray dimensions
                        trayWidth_inch = newW;
                        trayHeight_inch = newH;
                        
                        // Open preferences, save values, and close immediately
                        preferences.begin("machineCfg", false);
                        preferences.putFloat("trayWidth", trayWidth_inch);
                        preferences.putFloat("trayHeight", trayHeight_inch);
                        preferences.end();
                        
                        Serial.printf("[DEBUG] Set Tray Size to W=%.2f, H=%.2f\n", trayWidth_inch, trayHeight_inch);
                        
                        // Recalculate grid spacing with current grid dimensions to reflect new tray size
                        float oldGapX = placeGapX_inch;
                        float oldGapY = placeGapY_inch;
                        calculateAndSetGridSpacing(placeGridCols, placeGridRows);
                        
                        Serial.printf("[DEBUG] Gap values changed: X: %.3f  %.3f, Y: %.3f  %.3f\n", 
                                    oldGapX, placeGapX_inch, oldGapY, placeGapY_inch);
                        
                        // Instead of using a redundant call to sendAllSettingsUpdate, create a more specific message
                        // about the changes that were made
                        char msgBuffer[200];
                        sprintf(msgBuffer, "Tray Size updated to W=%.2f, H=%.2f. Gap recalculated: X=%.3f, Y=%.3f", 
                               trayWidth_inch, trayHeight_inch, placeGapX_inch, placeGapY_inch);
                        
                        // Send settings update to the specific client that requested the change
                        sendAllSettingsUpdate(num, msgBuffer);
                        // Also broadcast to all other clients
                        if (num != 255) {
                            sendAllSettingsUpdate(255, msgBuffer);
                        }
                    } else {
                        Serial.printf("[DEBUG] Failed to parse SET_TRAY_SIZE command: %s\n", command.c_str());
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid SET_TRAY_SIZE format.\"}");
                    }
                 } else if (command.startsWith("SET_PAINT_PATTERN_OFFSET ")) {
                    Serial.println("WebSocket: Received SET_PAINT_PATTERN_OFFSET command.");
                    if (isMoving || isHoming) { // Prevent changes while moving
                        webSocket.sendTXT(num, "{\"status\":\"Busy\",\"message\":\"Cannot set paint offsets while machine is busy.\"}");
                    } else {
                        float newX, newY;
                        int parsed = sscanf(command.c_str() + strlen("SET_PAINT_PATTERN_OFFSET "), "%f %f", &newX, &newY);
                        if (parsed == 2) {
                            paintPatternOffsetX_inch = newX;
                            paintPatternOffsetY_inch = newY;
                            // Save to Preferences
                            preferences.begin("machineCfg", false);
                            preferences.putFloat("paintPatOffX", paintPatternOffsetX_inch);
                            preferences.putFloat("paintPatOffY", paintPatternOffsetY_inch);
                            preferences.end();
                            Serial.printf("[DEBUG] Set Paint Pattern Offset to X: %.2f, Y: %.2f\n", paintPatternOffsetX_inch, paintPatternOffsetY_inch);
                            // Send confirmation with all settings
                            sendAllSettingsUpdate(num, "Paint Pattern Offset updated.");
                        } else {
                            webSocket.sendTXT(num, "{\"status\":\"Error\",\"message\":\"Invalid SET_PAINT_PATTERN_OFFSET format. Use: SET_PAINT_PATTERN_OFFSET X Y\"}");
                        }
                    }
                } else if (command.startsWith("SET_PAINT_GUN_OFFSET ")) {
                    Serial.println("WebSocket: Received SET_PAINT_GUN_OFFSET command.");
                     if (isMoving || isHoming) { // Prevent changes while moving
                        webSocket.sendTXT(num, "{\"status\":\"Busy\",\"message\":\"Cannot set paint offsets while machine is busy.\"}");
                    } else {
                        float newX, newY;
                        int parsed = sscanf(command.c_str() + strlen("SET_PAINT_GUN_OFFSET "), "%f %f", &newX, &newY);
                        if (parsed == 2) {
                            paintGunOffsetX_inch = newX;
                            paintGunOffsetY_inch = newY;
                            // Save to Preferences
                            preferences.begin("machineCfg", false);
                            preferences.putFloat("paintGunOffX", paintGunOffsetX_inch);
                            preferences.putFloat("paintGunOffY", paintGunOffsetY_inch);
                            preferences.end();
                            Serial.printf("[DEBUG] Set Paint Gun Offset to X: %.2f, Y: %.2f\n", paintGunOffsetX_inch, paintGunOffsetY_inch);
                            // Send confirmation with all settings
                            sendAllSettingsUpdate(num, "Paint Gun Offset updated.");
                        } else {
                            webSocket.sendTXT(num, "{\"status\":\"Error\",\"message\":\"Invalid SET_PAINT_GUN_OFFSET format. Use: SET_PAINT_GUN_OFFSET X Y\"}");
                        }
                    }
                } else if (command.startsWith("SET_PAINT_SIDE_SETTINGS ")) {
                    // Format: SET_PAINT_SIDE_SETTINGS sideIndex z pitch roll gun_orientation speed
                    Serial.println("WebSocket: Received SET_PAINT_SIDE_SETTINGS command.");
                    
                    // Parse command to extract parameters
                    String parts[6]; // Need 6 parts: sideIndex, z, pitch, roll, gunOrientation, speed
                    int partCount = 0;
                    int startPos = 23; // Skip "SET_PAINT_SIDE_SETTINGS "
                    
                    for (int i = 0; i < 6 && startPos < command.length(); i++) {
                        int spacePos = command.indexOf(' ', startPos);
                        if (spacePos == -1) {
                            // Last part
                            if (startPos < command.length()) {
                                parts[i] = command.substring(startPos);
                                partCount++;
                            }
                            break;
                        } else {
                            parts[i] = command.substring(startPos, spacePos);
                            startPos = spacePos + 1;
                            partCount++;
                        }
                    }
                    
                    if (partCount == 6) {
                        int sideIndex = parts[0].toInt();
                        float newZ = parts[1].toFloat();
                        int newPitch = parts[2].toInt();
                        int newRoll = parts[3].toInt();
                        int newGunOrientation = parts[4].toInt();
                        float newSpeed = parts[5].toFloat();
                        
                        // Validate parameters
                        if (sideIndex < 0 || sideIndex > 3) {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid side index\"}");
                            return;
                        }
                        
                        // Handle Z
                        if (newZ >= 0.0 && newZ <= 2.5) {
                            paintZHeight_inch[sideIndex] = newZ;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid Z height (must be between 0.0 and 2.5)\"}");
                            return;
                        }
                        
                        // Handle Pitch
                        if (newPitch >= 0 && newPitch <= 90) {
                            paintPitchAngle[sideIndex] = newPitch;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid pitch angle (must be between 0 and 90)\"}");
                            return;
                        }
                        
                        // Handle Roll
                        if (newRoll == 0 || newRoll == 90) {
                            paintRollAngle[sideIndex] = newRoll;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid roll angle (must be 0 or 90)\"}");
                            return;
                        }
                        
                        // Handle Gun Orientation
                        if (newGunOrientation == 0 || newGunOrientation == 90) {
                            paintGunOrientation[sideIndex] = newGunOrientation;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid gun orientation (must be 0 or 90)\"}");
                            return;
                        }
                        
                        // Handle Speed
                        if (newSpeed >= 5000.0 && newSpeed <= 25000.0) {
                            paintSpeed[sideIndex] = newSpeed;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid speed (must be between 5000 and 25000)\"}");
                            return;
                        }
                        
                        // Save to preferences
                        preferences.begin("paintSettings", false);
                        String keyZ = "paintZ_" + String(sideIndex);
                        String keyP = "paintP_" + String(sideIndex);
                        String keyR = "paintR_" + String(sideIndex);
                        String keyGO = "paintGO_" + String(sideIndex);
                        String keyS = "paintS_" + String(sideIndex);
                        
                        preferences.putFloat(keyZ.c_str(), paintZHeight_inch[sideIndex]);
                        preferences.putInt(keyP.c_str(), paintPitchAngle[sideIndex]);
                        preferences.putInt(keyR.c_str(), paintRollAngle[sideIndex]);
                        preferences.putInt(keyGO.c_str(), paintGunOrientation[sideIndex]);
                        preferences.putFloat(keyS.c_str(), paintSpeed[sideIndex]);
                        preferences.end();
                        
                        // Send response with updated values
                        char response[100];
                        sprintf(response, "{\"status\":\"Ready\", \"message\":\"Updated settings for side %d: Z=%.2f, P=%d, R=%d, GO=%d, S=%.1f\"}", 
                                sideIndex, paintZHeight_inch[sideIndex], paintPitchAngle[sideIndex], 
                                paintRollAngle[sideIndex], paintGunOrientation[sideIndex], paintSpeed[sideIndex]);
                        webSocket.broadcastTXT(response);
                        
                        // Also update all settings everywhere
                        sendAllSettingsUpdate(ALL_CLIENTS, "");
                    } else {
                        webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid SET_PAINT_SIDE_SETTINGS format\"}");
                    }
                } else if (command.startsWith("JOG ")) {
                    // Serial.println("WebSocket: Received JOG command.");
                    if (!inCalibrationMode) {
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Must be in calibration mode to jog.\"}");
                    } else if (isMoving || isHoming) {
                        webSocket.sendTXT(num, "{\"status\":\"Busy\", \"message\":\"Cannot jog while machine is moving.\"}");
                    } else {
                        char axis;
                        float distance_inch;
                        int parsed = sscanf(command.c_str() + strlen("JOG "), "%c %f", &axis, &distance_inch);
                        
                        if (parsed == 2) {
                            long current_steps = 0;
                            long jog_steps = 0;
                            FastAccelStepper* stepper_to_move = NULL;
                            float speed = 0, accel = 0;

                            if (axis == 'X' && stepper_x) {
                                stepper_to_move = stepper_x;
                                current_steps = stepper_x->getCurrentPosition();
                                jog_steps = (long)(distance_inch * STEPS_PER_INCH_XY);
                                speed = patternXSpeed;
                                accel = patternXAccel;
                            } else if (axis == 'Y' && stepper_y_left && stepper_y_right) { // Assuming both Y move together
                                stepper_to_move = stepper_y_left; // Use left for current pos, command both
                                current_steps = stepper_y_left->getCurrentPosition();
                                jog_steps = (long)(distance_inch * STEPS_PER_INCH_XY);
                                speed = patternYSpeed;
                                accel = patternYAccel;
                            } else {
                                Serial.printf("[ERROR] Invalid axis '%c' or stepper not available for JOG.\n", axis);
                                webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid axis for jog.\"}");
                            }

                            if (stepper_to_move) {
                                isMoving = true; // Set flag, loop() will handle completion
                                webSocket.broadcastTXT("{\"status\":\"Busy\", \"message\":\"Jogging...\"}");
                                
                                long target_steps = current_steps + jog_steps;
                                //Serial.printf("  Jogging %c by %.3f inches (%ld steps) from %ld to %ld\n", axis, distance_inch, jog_steps, current_steps, target_steps);

                                stepper_to_move->setSpeedInHz(speed);
                                stepper_to_move->setAcceleration(accel);
                                stepper_to_move->moveTo(target_steps);

                                if (axis == 'Y' && stepper_y_right) { // Command right Y too
                                    stepper_y_right->setSpeedInHz(speed);
                                    stepper_y_right->setAcceleration(accel);
                                    stepper_y_right->moveTo(target_steps);
                                }
                            }
                        } else {
                            Serial.println("[ERROR] Failed to parse JOG command.");
                            webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid JOG format. Use: JOG X/Y distance\"}");
                        }
                    }
                 } else if (command.startsWith("MOVE_TO_COORDS ")) {
                    Serial.println("WebSocket: Received MOVE_TO_COORDS command.");
                    if (!inCalibrationMode) {
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Must be in calibration mode to move to coordinates.\"}");
                    } else if (isMoving || isHoming) {
                        webSocket.sendTXT(num, "{\"status\":\"Busy\", \"message\":\"Cannot move while machine is busy.\"}");
                    } else {
                        float targetX_inch, targetY_inch;
                        int parsed = sscanf(command.c_str() + strlen("MOVE_TO_COORDS "), "%f %f", &targetX_inch, &targetY_inch);
                        
                        if (parsed == 2) {
                            // Validate coordinates (optional, add bounds checking if needed)
                            if (targetX_inch < 0 || targetY_inch < 0) {
                                webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid coordinates. Must be non-negative.\"}");
                                return;
                            }
                            
                            // Set up the move
                            isMoving = true; // Set flag, loop() will handle completion
                            webSocket.broadcastTXT("{\"status\":\"Busy\", \"message\":\"Moving to coordinates...\"}");
                            
                            // Convert to steps
                            long targetX_steps = (long)(targetX_inch * STEPS_PER_INCH_XY);
                            long targetY_steps = (long)(targetY_inch * STEPS_PER_INCH_XY);
                            
                            // Command the move
                            if (stepper_x) {
                                stepper_x->setSpeedInHz(patternXSpeed);
                                stepper_x->setAcceleration(patternXAccel);
                                stepper_x->moveTo(targetX_steps);
                            }
                            
                            if (stepper_y_left && stepper_y_right) {
                                stepper_y_left->setSpeedInHz(patternYSpeed);
                                stepper_y_left->setAcceleration(patternYAccel);
                                stepper_y_left->moveTo(targetY_steps);
                                
                                stepper_y_right->setSpeedInHz(patternYSpeed);
                                stepper_y_right->setAcceleration(patternYAccel);
                                stepper_y_right->moveTo(targetY_steps);
                            }
                        } else {
                            Serial.println("[ERROR] Failed to parse MOVE_TO_COORDS command.");
                            webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid format. Use: MOVE_TO_COORDS X Y\"}");
                         }
                     }
                 } else if (command.startsWith("SET_GRID_SPACING ")) { // UPDATED
                    Serial.println("[DEBUG] webSocketEvent: Handling SET_GRID_SPACING command."); // DEBUG
                    int newCols, newRows;
                    // Expecting "SET_GRID_SPACING C R"
                    int parsed = sscanf(command.c_str() + strlen("SET_GRID_SPACING "), "%d %d", &newCols, &newRows);
                    if (parsed == 2 && newCols > 0 && newRows > 0) {
                        // Call the new calculation function
                        calculateAndSetGridSpacing(newCols, newRows);
                    } else {
                        Serial.printf("[DEBUG] Failed to parse SET_GRID_SPACING command: %s\n", command.c_str());
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid SET_GRID_SPACING format. Use C R (integers > 0)\"}");
                    }
                 } else if (command.startsWith("SET_TRAY_SIZE ")) { // NEW
                    Serial.println("[DEBUG] webSocketEvent: Handling SET_TRAY_SIZE command."); // DEBUG
                    float newW, newH;
                    // Expecting "SET_TRAY_SIZE W H"
                    int parsed = sscanf(command.c_str() + strlen("SET_TRAY_SIZE "), "%f %f", &newW, &newH);
                    if (parsed == 2 && newW > 0 && newH > 0) {
                        Serial.printf("[DEBUG] New tray dimensions: width=%.2f, height=%.2f (old: width=%.2f, height=%.2f)\n", 
                                    newW, newH, trayWidth_inch, trayHeight_inch);
                        
                        // Save the new tray dimensions
                        trayWidth_inch = newW;
                        trayHeight_inch = newH;
                        
                        // Open preferences, save values, and close immediately
                        preferences.begin("machineCfg", false);
                        preferences.putFloat("trayWidth", trayWidth_inch);
                        preferences.putFloat("trayHeight", trayHeight_inch);
                        preferences.end();
                        
                        Serial.printf("[DEBUG] Set Tray Size to W=%.2f, H=%.2f\n", trayWidth_inch, trayHeight_inch);
                        
                        // Recalculate grid spacing with current grid dimensions to reflect new tray size
                        float oldGapX = placeGapX_inch;
                        float oldGapY = placeGapY_inch;
                        calculateAndSetGridSpacing(placeGridCols, placeGridRows);
                        
                        Serial.printf("[DEBUG] Gap values changed: X: %.3f  %.3f, Y: %.3f  %.3f\n", 
                                    oldGapX, placeGapX_inch, oldGapY, placeGapY_inch);
                        
                        // Instead of using a redundant call to sendAllSettingsUpdate, create a more specific message
                        // about the changes that were made
                        char msgBuffer[200];
                        sprintf(msgBuffer, "Tray Size updated to W=%.2f, H=%.2f. Gap recalculated: X=%.3f, Y=%.3f", 
                               trayWidth_inch, trayHeight_inch, placeGapX_inch, placeGapY_inch);
                        
                        // Send settings update to the specific client that requested the change
                        sendAllSettingsUpdate(num, msgBuffer);
                        // Also broadcast to all other clients
                        if (num != 255) {
                            sendAllSettingsUpdate(255, msgBuffer);
                        }
                    } else {
                        Serial.printf("[DEBUG] Failed to parse SET_TRAY_SIZE command: %s\n", command.c_str());
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid SET_TRAY_SIZE format.\"}");
                    }
                 } else if (command.startsWith("SET_PAINT_PATTERN_OFFSET ")) {
                    Serial.println("WebSocket: Received SET_PAINT_PATTERN_OFFSET command.");
                    if (isMoving || isHoming) { // Prevent changes while moving
                        webSocket.sendTXT(num, "{\"status\":\"Busy\",\"message\":\"Cannot set paint offsets while machine is busy.\"}");
                    } else {
                        float newX, newY;
                        int parsed = sscanf(command.c_str() + strlen("SET_PAINT_PATTERN_OFFSET "), "%f %f", &newX, &newY);
                        if (parsed == 2) {
                            paintPatternOffsetX_inch = newX;
                            paintPatternOffsetY_inch = newY;
                            // Save to Preferences
                            preferences.begin("machineCfg", false);
                            preferences.putFloat("paintPatOffX", paintPatternOffsetX_inch);
                            preferences.putFloat("paintPatOffY", paintPatternOffsetY_inch);
                            preferences.end();
                            Serial.printf("[DEBUG] Set Paint Pattern Offset to X: %.2f, Y: %.2f\n", paintPatternOffsetX_inch, paintPatternOffsetY_inch);
                            // Send confirmation with all settings
                            sendAllSettingsUpdate(num, "Paint Pattern Offset updated.");
                        } else {
                            webSocket.sendTXT(num, "{\"status\":\"Error\",\"message\":\"Invalid SET_PAINT_PATTERN_OFFSET format. Use: SET_PAINT_PATTERN_OFFSET X Y\"}");
                        }
                    }
                } else if (command.startsWith("SET_PAINT_GUN_OFFSET ")) {
                    Serial.println("WebSocket: Received SET_PAINT_GUN_OFFSET command.");
                     if (isMoving || isHoming) { // Prevent changes while moving
                        webSocket.sendTXT(num, "{\"status\":\"Busy\",\"message\":\"Cannot set paint offsets while machine is busy.\"}");
                    } else {
                        float newX, newY;
                        int parsed = sscanf(command.c_str() + strlen("SET_PAINT_GUN_OFFSET "), "%f %f", &newX, &newY);
                        if (parsed == 2) {
                            paintGunOffsetX_inch = newX;
                            paintGunOffsetY_inch = newY;
                            // Save to Preferences
                            preferences.begin("machineCfg", false);
                            preferences.putFloat("paintGunOffX", paintGunOffsetX_inch);
                            preferences.putFloat("paintGunOffY", paintGunOffsetY_inch);
                            preferences.end();
                            Serial.printf("[DEBUG] Set Paint Gun Offset to X: %.2f, Y: %.2f\n", paintGunOffsetX_inch, paintGunOffsetY_inch);
                            // Send confirmation with all settings
                            sendAllSettingsUpdate(num, "Paint Gun Offset updated.");
                        } else {
                            webSocket.sendTXT(num, "{\"status\":\"Error\",\"message\":\"Invalid SET_PAINT_GUN_OFFSET format. Use: SET_PAINT_GUN_OFFSET X Y\"}");
                        }
                    }
                } else if (command.startsWith("SET_PAINT_SIDE_SETTINGS ")) {
                    // Format: SET_PAINT_SIDE_SETTINGS sideIndex z pitch roll gun_orientation speed
                    Serial.println("WebSocket: Received SET_PAINT_SIDE_SETTINGS command.");
                    
                    // Parse command to extract parameters
                    String parts[6]; // Need 6 parts: sideIndex, z, pitch, roll, gunOrientation, speed
                    int partCount = 0;
                    int startPos = 23; // Skip "SET_PAINT_SIDE_SETTINGS "
                    
                    for (int i = 0; i < 6 && startPos < command.length(); i++) {
                        int spacePos = command.indexOf(' ', startPos);
                        if (spacePos == -1) {
                            // Last part
                            if (startPos < command.length()) {
                                parts[i] = command.substring(startPos);
                                partCount++;
                            }
                            break;
                        } else {
                            parts[i] = command.substring(startPos, spacePos);
                            startPos = spacePos + 1;
                            partCount++;
                        }
                    }
                    
                    if (partCount == 6) {
                        int sideIndex = parts[0].toInt();
                        float newZ = parts[1].toFloat();
                        int newPitch = parts[2].toInt();
                        int newRoll = parts[3].toInt();
                        int newGunOrientation = parts[4].toInt();
                        float newSpeed = parts[5].toFloat();
                        
                        // Validate parameters
                        if (sideIndex < 0 || sideIndex > 3) {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid side index\"}");
                            return;
                        }
                        
                        // Handle Z
                        if (newZ >= 0.0 && newZ <= 2.5) {
                            paintZHeight_inch[sideIndex] = newZ;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid Z height (must be between 0.0 and 2.5)\"}");
                            return;
                        }
                        
                        // Handle Pitch
                        if (newPitch >= 0 && newPitch <= 90) {
                            paintPitchAngle[sideIndex] = newPitch;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid pitch angle (must be between 0 and 90)\"}");
                            return;
                        }
                        
                        // Handle Roll
                        if (newRoll == 0 || newRoll == 90) {
                            paintRollAngle[sideIndex] = newRoll;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid roll angle (must be 0 or 90)\"}");
                            return;
                        }
                        
                        // Handle Gun Orientation
                        if (newGunOrientation == 0 || newGunOrientation == 90) {
                            paintGunOrientation[sideIndex] = newGunOrientation;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid gun orientation (must be 0 or 90)\"}");
                            return;
                        }
                        
                        // Handle Speed
                        if (newSpeed >= 5000.0 && newSpeed <= 25000.0) {
                            paintSpeed[sideIndex] = newSpeed;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid speed (must be between 5000 and 25000)\"}");
                            return;
                        }
                        
                        // Save to preferences
                        preferences.begin("paintSettings", false);
                        String keyZ = "paintZ_" + String(sideIndex);
                        String keyP = "paintP_" + String(sideIndex);
                        String keyR = "paintR_" + String(sideIndex);
                        String keyGO = "paintGO_" + String(sideIndex);
                        String keyS = "paintS_" + String(sideIndex);
                        
                        preferences.putFloat(keyZ.c_str(), paintZHeight_inch[sideIndex]);
                        preferences.putInt(keyP.c_str(), paintPitchAngle[sideIndex]);
                        preferences.putInt(keyR.c_str(), paintRollAngle[sideIndex]);
                        preferences.putInt(keyGO.c_str(), paintGunOrientation[sideIndex]);
                        preferences.putFloat(keyS.c_str(), paintSpeed[sideIndex]);
                        preferences.end();
                        
                        // Send response with updated values
                        char response[100];
                        sprintf(response, "{\"status\":\"Ready\", \"message\":\"Updated settings for side %d: Z=%.2f, P=%d, R=%d, GO=%d, S=%.1f\"}", 
                                sideIndex, paintZHeight_inch[sideIndex], paintPitchAngle[sideIndex], 
                                paintRollAngle[sideIndex], paintGunOrientation[sideIndex], paintSpeed[sideIndex]);
                        webSocket.broadcastTXT(response);
                        
                        // Also update all settings everywhere
                        sendAllSettingsUpdate(ALL_CLIENTS, "");
                    } else {
                        webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid SET_PAINT_SIDE_SETTINGS format\"}");
                    }
                } else if (command.startsWith("JOG ")) {
                    // Serial.println("WebSocket: Received JOG command.");
                    if (!inCalibrationMode) {
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Must be in calibration mode to jog.\"}");
                    } else if (isMoving || isHoming) {
                        webSocket.sendTXT(num, "{\"status\":\"Busy\", \"message\":\"Cannot jog while machine is moving.\"}");
                    } else {
                        char axis;
                        float distance_inch;
                        int parsed = sscanf(command.c_str() + strlen("JOG "), "%c %f", &axis, &distance_inch);
                        
                        if (parsed == 2) {
                            long current_steps = 0;
                            long jog_steps = 0;
                            FastAccelStepper* stepper_to_move = NULL;
                            float speed = 0, accel = 0;

                            if (axis == 'X' && stepper_x) {
                                stepper_to_move = stepper_x;
                                current_steps = stepper_x->getCurrentPosition();
                                jog_steps = (long)(distance_inch * STEPS_PER_INCH_XY);
                                speed = patternXSpeed;
                                accel = patternXAccel;
                            } else if (axis == 'Y' && stepper_y_left && stepper_y_right) { // Assuming both Y move together
                                stepper_to_move = stepper_y_left; // Use left for current pos, command both
                                current_steps = stepper_y_left->getCurrentPosition();
                                jog_steps = (long)(distance_inch * STEPS_PER_INCH_XY);
                                speed = patternYSpeed;
                                accel = patternYAccel;
                            } else {
                                Serial.printf("[ERROR] Invalid axis '%c' or stepper not available for JOG.\n", axis);
                                webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid axis for jog.\"}");
                            }

                            if (stepper_to_move) {
                                isMoving = true; // Set flag, loop() will handle completion
                                webSocket.broadcastTXT("{\"status\":\"Busy\", \"message\":\"Jogging...\"}");
                                
                                long target_steps = current_steps + jog_steps;
                                //Serial.printf("  Jogging %c by %.3f inches (%ld steps) from %ld to %ld\n", axis, distance_inch, jog_steps, current_steps, target_steps);

                                stepper_to_move->setSpeedInHz(speed);
                                stepper_to_move->setAcceleration(accel);
                                stepper_to_move->moveTo(target_steps);

                                if (axis == 'Y' && stepper_y_right) { // Command right Y too
                                    stepper_y_right->setSpeedInHz(speed);
                                    stepper_y_right->setAcceleration(accel);
                                    stepper_y_right->moveTo(target_steps);
                                }
                            }
                        } else {
                            Serial.println("[ERROR] Failed to parse JOG command.");
                            webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid JOG format. Use: JOG X/Y distance\"}");
                        }
                    }
                 } else if (command.startsWith("MOVE_TO_COORDS ")) {
                    Serial.println("WebSocket: Received MOVE_TO_COORDS command.");
                    if (!inCalibrationMode) {
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Must be in calibration mode to move to coordinates.\"}");
                    } else if (isMoving || isHoming) {
                        webSocket.sendTXT(num, "{\"status\":\"Busy\", \"message\":\"Cannot move while machine is busy.\"}");
                    } else {
                        float targetX_inch, targetY_inch;
                        int parsed = sscanf(command.c_str() + strlen("MOVE_TO_COORDS "), "%f %f", &targetX_inch, &targetY_inch);
                        
                        if (parsed == 2) {
                            // Validate coordinates (optional, add bounds checking if needed)
                            if (targetX_inch < 0 || targetY_inch < 0) {
                                webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid coordinates. Must be non-negative.\"}");
                                return;
                            }
                            
                            // Set up the move
                            isMoving = true; // Set flag, loop() will handle completion
                            webSocket.broadcastTXT("{\"status\":\"Busy\", \"message\":\"Moving to coordinates...\"}");
                            
                            // Convert to steps
                            long targetX_steps = (long)(targetX_inch * STEPS_PER_INCH_XY);
                            long targetY_steps = (long)(targetY_inch * STEPS_PER_INCH_XY);
                            
                            // Command the move
                            if (stepper_x) {
                                stepper_x->setSpeedInHz(patternXSpeed);
                                stepper_x->setAcceleration(patternXAccel);
                                stepper_x->moveTo(targetX_steps);
                            }
                            
                            if (stepper_y_left && stepper_y_right) {
                                stepper_y_left->setSpeedInHz(patternYSpeed);
                                stepper_y_left->setAcceleration(patternYAccel);
                                stepper_y_left->moveTo(targetY_steps);
                                
                                stepper_y_right->setSpeedInHz(patternYSpeed);
                                stepper_y_right->setAcceleration(patternYAccel);
                                stepper_y_right->moveTo(targetY_steps);
                            }
                        } else {
                            Serial.println("[ERROR] Failed to parse MOVE_TO_COORDS command.");
                            webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid format. Use: MOVE_TO_COORDS X Y\"}");
                         }
                     }
                 } else if (command.startsWith("SET_GRID_SPACING ")) { // UPDATED
                    Serial.println("[DEBUG] webSocketEvent: Handling SET_GRID_SPACING command."); // DEBUG
                    int newCols, newRows;
                    // Expecting "SET_GRID_SPACING C R"
                    int parsed = sscanf(command.c_str() + strlen("SET_GRID_SPACING "), "%d %d", &newCols, &newRows);
                    if (parsed == 2 && newCols > 0 && newRows > 0) {
                        // Call the new calculation function
                        calculateAndSetGridSpacing(newCols, newRows);
                    } else {
                        Serial.printf("[DEBUG] Failed to parse SET_GRID_SPACING command: %s\n", command.c_str());
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid SET_GRID_SPACING format. Use C R (integers > 0)\"}");
                    }
                 } else if (command.startsWith("SET_TRAY_SIZE ")) { // NEW
                    Serial.println("[DEBUG] webSocketEvent: Handling SET_TRAY_SIZE command."); // DEBUG
                    float newW, newH;
                    // Expecting "SET_TRAY_SIZE W H"
                    int parsed = sscanf(command.c_str() + strlen("SET_TRAY_SIZE "), "%f %f", &newW, &newH);
                    if (parsed == 2 && newW > 0 && newH > 0) {
                        Serial.printf("[DEBUG] New tray dimensions: width=%.2f, height=%.2f (old: width=%.2f, height=%.2f)\n", 
                                    newW, newH, trayWidth_inch, trayHeight_inch);
                        
                        // Save the new tray dimensions
                        trayWidth_inch = newW;
                        trayHeight_inch = newH;
                        
                        // Open preferences, save values, and close immediately
                        preferences.begin("machineCfg", false);
                        preferences.putFloat("trayWidth", trayWidth_inch);
                        preferences.putFloat("trayHeight", trayHeight_inch);
                        preferences.end();
                        
                        Serial.printf("[DEBUG] Set Tray Size to W=%.2f, H=%.2f\n", trayWidth_inch, trayHeight_inch);
                        
                        // Recalculate grid spacing with current grid dimensions to reflect new tray size
                        float oldGapX = placeGapX_inch;
                        float oldGapY = placeGapY_inch;
                        calculateAndSetGridSpacing(placeGridCols, placeGridRows);
                        
                        Serial.printf("[DEBUG] Gap values changed: X: %.3f  %.3f, Y: %.3f  %.3f\n", 
                                    oldGapX, placeGapX_inch, oldGapY, placeGapY_inch);
                        
                        // Instead of using a redundant call to sendAllSettingsUpdate, create a more specific message
                        // about the changes that were made
                        char msgBuffer[200];
                        sprintf(msgBuffer, "Tray Size updated to W=%.2f, H=%.2f. Gap recalculated: X=%.3f, Y=%.3f", 
                               trayWidth_inch, trayHeight_inch, placeGapX_inch, placeGapY_inch);
                        
                        // Send settings update to the specific client that requested the change
                        sendAllSettingsUpdate(num, msgBuffer);
                        // Also broadcast to all other clients
                        if (num != 255) {
                            sendAllSettingsUpdate(255, msgBuffer);
                        }
                    } else {
                        Serial.printf("[DEBUG] Failed to parse SET_TRAY_SIZE command: %s\n", command.c_str());
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid SET_TRAY_SIZE format.\"}");
                    }
                 } else if (command.startsWith("SET_PAINT_PATTERN_OFFSET ")) {
                    Serial.println("WebSocket: Received SET_PAINT_PATTERN_OFFSET command.");
                    if (isMoving || isHoming) { // Prevent changes while moving
                        webSocket.sendTXT(num, "{\"status\":\"Busy\",\"message\":\"Cannot set paint offsets while machine is busy.\"}");
                    } else {
                        float newX, newY;
                        int parsed = sscanf(command.c_str() + strlen("SET_PAINT_PATTERN_OFFSET "), "%f %f", &newX, &newY);
                        if (parsed == 2) {
                            paintPatternOffsetX_inch = newX;
                            paintPatternOffsetY_inch = newY;
                            // Save to Preferences
                            preferences.begin("machineCfg", false);
                            preferences.putFloat("paintPatOffX", paintPatternOffsetX_inch);
                            preferences.putFloat("paintPatOffY", paintPatternOffsetY_inch);
                            preferences.end();
                            Serial.printf("[DEBUG] Set Paint Pattern Offset to X: %.2f, Y: %.2f\n", paintPatternOffsetX_inch, paintPatternOffsetY_inch);
                            // Send confirmation with all settings
                            sendAllSettingsUpdate(num, "Paint Pattern Offset updated.");
                        } else {
                            webSocket.sendTXT(num, "{\"status\":\"Error\",\"message\":\"Invalid SET_PAINT_PATTERN_OFFSET format. Use: SET_PAINT_PATTERN_OFFSET X Y\"}");
                        }
                    }
                } else if (command.startsWith("SET_PAINT_GUN_OFFSET ")) {
                    Serial.println("WebSocket: Received SET_PAINT_GUN_OFFSET command.");
                     if (isMoving || isHoming) { // Prevent changes while moving
                        webSocket.sendTXT(num, "{\"status\":\"Busy\",\"message\":\"Cannot set paint offsets while machine is busy.\"}");
                    } else {
                        float newX, newY;
                        int parsed = sscanf(command.c_str() + strlen("SET_PAINT_GUN_OFFSET "), "%f %f", &newX, &newY);
                        if (parsed == 2) {
                            paintGunOffsetX_inch = newX;
                            paintGunOffsetY_inch = newY;
                            // Save to Preferences
                            preferences.begin("machineCfg", false);
                            preferences.putFloat("paintGunOffX", paintGunOffsetX_inch);
                            preferences.putFloat("paintGunOffY", paintGunOffsetY_inch);
                            preferences.end();
                            Serial.printf("[DEBUG] Set Paint Gun Offset to X: %.2f, Y: %.2f\n", paintGunOffsetX_inch, paintGunOffsetY_inch);
                            // Send confirmation with all settings
                            sendAllSettingsUpdate(num, "Paint Gun Offset updated.");
                        } else {
                            webSocket.sendTXT(num, "{\"status\":\"Error\",\"message\":\"Invalid SET_PAINT_GUN_OFFSET format. Use: SET_PAINT_GUN_OFFSET X Y\"}");
                        }
                    }
                } else if (command.startsWith("SET_PAINT_SIDE_SETTINGS ")) {
                    // Format: SET_PAINT_SIDE_SETTINGS sideIndex z pitch roll gun_orientation speed
                    Serial.println("WebSocket: Received SET_PAINT_SIDE_SETTINGS command.");
                    
                    // Parse command to extract parameters
                    String parts[6]; // Need 6 parts: sideIndex, z, pitch, roll, gunOrientation, speed
                    int partCount = 0;
                    int startPos = 23; // Skip "SET_PAINT_SIDE_SETTINGS "
                    
                    for (int i = 0; i < 6 && startPos < command.length(); i++) {
                        int spacePos = command.indexOf(' ', startPos);
                        if (spacePos == -1) {
                            // Last part
                            if (startPos < command.length()) {
                                parts[i] = command.substring(startPos);
                                partCount++;
                            }
                            break;
                        } else {
                            parts[i] = command.substring(startPos, spacePos);
                            startPos = spacePos + 1;
                            partCount++;
                        }
                    }
                    
                    if (partCount == 6) {
                        int sideIndex = parts[0].toInt();
                        float newZ = parts[1].toFloat();
                        int newPitch = parts[2].toInt();
                        int newRoll = parts[3].toInt();
                        int newGunOrientation = parts[4].toInt();
                        float newSpeed = parts[5].toFloat();
                        
                        // Validate parameters
                        if (sideIndex < 0 || sideIndex > 3) {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid side index\"}");
                            return;
                        }
                        
                        // Handle Z
                        if (newZ >= 0.0 && newZ <= 2.5) {
                            paintZHeight_inch[sideIndex] = newZ;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid Z height (must be between 0.0 and 2.5)\"}");
                            return;
                        }
                        
                        // Handle Pitch
                        if (newPitch >= 0 && newPitch <= 90) {
                            paintPitchAngle[sideIndex] = newPitch;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid pitch angle (must be between 0 and 90)\"}");
                            return;
                        }
                        
                        // Handle Roll
                        if (newRoll == 0 || newRoll == 90) {
                            paintRollAngle[sideIndex] = newRoll;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid roll angle (must be 0 or 90)\"}");
                            return;
                        }
                        
                        // Handle Gun Orientation
                        if (newGunOrientation == 0 || newGunOrientation == 90) {
                            paintGunOrientation[sideIndex] = newGunOrientation;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid gun orientation (must be 0 or 90)\"}");
                            return;
                        }
                        
                        // Handle Speed
                        if (newSpeed >= 5000.0 && newSpeed <= 25000.0) {
                            paintSpeed[sideIndex] = newSpeed;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid speed (must be between 5000 and 25000)\"}");
                            return;
                        }
                        
                        // Save to preferences
                        preferences.begin("paintSettings", false);
                        String keyZ = "paintZ_" + String(sideIndex);
                        String keyP = "paintP_" + String(sideIndex);
                        String keyR = "paintR_" + String(sideIndex);
                        String keyGO = "paintGO_" + String(sideIndex);
                        String keyS = "paintS_" + String(sideIndex);
                        
                        preferences.putFloat(keyZ.c_str(), paintZHeight_inch[sideIndex]);
                        preferences.putInt(keyP.c_str(), paintPitchAngle[sideIndex]);
                        preferences.putInt(keyR.c_str(), paintRollAngle[sideIndex]);
                        preferences.putInt(keyGO.c_str(), paintGunOrientation[sideIndex]);
                        preferences.putFloat(keyS.c_str(), paintSpeed[sideIndex]);
                        preferences.end();
                        
                        // Send response with updated values
                        char response[100];
                        sprintf(response, "{\"status\":\"Ready\", \"message\":\"Updated settings for side %d: Z=%.2f, P=%d, R=%d, GO=%d, S=%.1f\"}", 
                                sideIndex, paintZHeight_inch[sideIndex], paintPitchAngle[sideIndex], 
                                paintRollAngle[sideIndex], paintGunOrientation[sideIndex], paintSpeed[sideIndex]);
                        webSocket.broadcastTXT(response);
                        
                        // Also update all settings everywhere
                        sendAllSettingsUpdate(ALL_CLIENTS, "");
                    } else {
                        webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid SET_PAINT_SIDE_SETTINGS format\"}");
                    }
                } else if (command.startsWith("JOG ")) {
                    // Serial.println("WebSocket: Received JOG command.");
                    if (!inCalibrationMode) {
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Must be in calibration mode to jog.\"}");
                    } else if (isMoving || isHoming) {
                        webSocket.sendTXT(num, "{\"status\":\"Busy\", \"message\":\"Cannot jog while machine is moving.\"}");
                    } else {
                        char axis;
                        float distance_inch;
                        int parsed = sscanf(command.c_str() + strlen("JOG "), "%c %f", &axis, &distance_inch);
                        
                        if (parsed == 2) {
                            long current_steps = 0;
                            long jog_steps = 0;
                            FastAccelStepper* stepper_to_move = NULL;
                            float speed = 0, accel = 0;

                            if (axis == 'X' && stepper_x) {
                                stepper_to_move = stepper_x;
                                current_steps = stepper_x->getCurrentPosition();
                                jog_steps = (long)(distance_inch * STEPS_PER_INCH_XY);
                                speed = patternXSpeed;
                                accel = patternXAccel;
                            } else if (axis == 'Y' && stepper_y_left && stepper_y_right) { // Assuming both Y move together
                                stepper_to_move = stepper_y_left; // Use left for current pos, command both
                                current_steps = stepper_y_left->getCurrentPosition();
                                jog_steps = (long)(distance_inch * STEPS_PER_INCH_XY);
                                speed = patternYSpeed;
                                accel = patternYAccel;
                            } else {
                                Serial.printf("[ERROR] Invalid axis '%c' or stepper not available for JOG.\n", axis);
                                webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid axis for jog.\"}");
                            }

                            if (stepper_to_move) {
                                isMoving = true; // Set flag, loop() will handle completion
                                webSocket.broadcastTXT("{\"status\":\"Busy\", \"message\":\"Jogging...\"}");
                                
                                long target_steps = current_steps + jog_steps;
                                //Serial.printf("  Jogging %c by %.3f inches (%ld steps) from %ld to %ld\n", axis, distance_inch, jog_steps, current_steps, target_steps);

                                stepper_to_move->setSpeedInHz(speed);
                                stepper_to_move->setAcceleration(accel);
                                stepper_to_move->moveTo(target_steps);

                                if (axis == 'Y' && stepper_y_right) { // Command right Y too
                                    stepper_y_right->setSpeedInHz(speed);
                                    stepper_y_right->setAcceleration(accel);
                                    stepper_y_right->moveTo(target_steps);
                                }
                            }
                        } else {
                            Serial.println("[ERROR] Failed to parse JOG command.");
                            webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid JOG format. Use: JOG X/Y distance\"}");
                        }
                    }
                 } else if (command.startsWith("MOVE_TO_COORDS ")) {
                    Serial.println("WebSocket: Received MOVE_TO_COORDS command.");
                    if (!inCalibrationMode) {
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Must be in calibration mode to move to coordinates.\"}");
                    } else if (isMoving || isHoming) {
                        webSocket.sendTXT(num, "{\"status\":\"Busy\", \"message\":\"Cannot move while machine is busy.\"}");
                    } else {
                        float targetX_inch, targetY_inch;
                        int parsed = sscanf(command.c_str() + strlen("MOVE_TO_COORDS "), "%f %f", &targetX_inch, &targetY_inch);
                        
                        if (parsed == 2) {
                            // Validate coordinates (optional, add bounds checking if needed)
                            if (targetX_inch < 0 || targetY_inch < 0) {
                                webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid coordinates. Must be non-negative.\"}");
                                return;
                            }
                            
                            // Set up the move
                            isMoving = true; // Set flag, loop() will handle completion
                            webSocket.broadcastTXT("{\"status\":\"Busy\", \"message\":\"Moving to coordinates...\"}");
                            
                            // Convert to steps
                            long targetX_steps = (long)(targetX_inch * STEPS_PER_INCH_XY);
                            long targetY_steps = (long)(targetY_inch * STEPS_PER_INCH_XY);
                            
                            // Command the move
                            if (stepper_x) {
                                stepper_x->setSpeedInHz(patternXSpeed);
                                stepper_x->setAcceleration(patternXAccel);
                                stepper_x->moveTo(targetX_steps);
                            }
                            
                            if (stepper_y_left && stepper_y_right) {
                                stepper_y_left->setSpeedInHz(patternYSpeed);
                                stepper_y_left->setAcceleration(patternYAccel);
                                stepper_y_left->moveTo(targetY_steps);
                                
                                stepper_y_right->setSpeedInHz(patternYSpeed);
                                stepper_y_right->setAcceleration(patternYAccel);
                                stepper_y_right->moveTo(targetY_steps);
                            }
                        } else {
                            Serial.println("[ERROR] Failed to parse MOVE_TO_COORDS command.");
                            webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid format. Use: MOVE_TO_COORDS X Y\"}");
                         }
                     }
                 } else if (command.startsWith("SET_GRID_SPACING ")) { // UPDATED
                    Serial.println("[DEBUG] webSocketEvent: Handling SET_GRID_SPACING command."); // DEBUG
                    int newCols, newRows;
                    // Expecting "SET_GRID_SPACING C R"
                    int parsed = sscanf(command.c_str() + strlen("SET_GRID_SPACING "), "%d %d", &newCols, &newRows);
                    if (parsed == 2 && newCols > 0 && newRows > 0) {
                        // Call the new calculation function
                        calculateAndSetGridSpacing(newCols, newRows);
                    } else {
                        Serial.printf("[DEBUG] Failed to parse SET_GRID_SPACING command: %s\n", command.c_str());
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid SET_GRID_SPACING format. Use C R (integers > 0)\"}");
                    }
                 } else if (command.startsWith("SET_TRAY_SIZE ")) { // NEW
                    Serial.println("[DEBUG] webSocketEvent: Handling SET_TRAY_SIZE command."); // DEBUG
                    float newW, newH;
                    // Expecting "SET_TRAY_SIZE W H"
                    int parsed = sscanf(command.c_str() + strlen("SET_TRAY_SIZE "), "%f %f", &newW, &newH);
                    if (parsed == 2 && newW > 0 && newH > 0) {
                        Serial.printf("[DEBUG] New tray dimensions: width=%.2f, height=%.2f (old: width=%.2f, height=%.2f)\n", 
                                    newW, newH, trayWidth_inch, trayHeight_inch);
                        
                        // Save the new tray dimensions
                        trayWidth_inch = newW;
                        trayHeight_inch = newH;
                        
                        // Open preferences, save values, and close immediately
                        preferences.begin("machineCfg", false);
                        preferences.putFloat("trayWidth", trayWidth_inch);
                        preferences.putFloat("trayHeight", trayHeight_inch);
                        preferences.end();
                        
                        Serial.printf("[DEBUG] Set Tray Size to W=%.2f, H=%.2f\n", trayWidth_inch, trayHeight_inch);
                        
                        // Recalculate grid spacing with current grid dimensions to reflect new tray size
                        float oldGapX = placeGapX_inch;
                        float oldGapY = placeGapY_inch;
                        calculateAndSetGridSpacing(placeGridCols, placeGridRows);
                        
                        Serial.printf("[DEBUG] Gap values changed: X: %.3f  %.3f, Y: %.3f  %.3f\n", 
                                    oldGapX, placeGapX_inch, oldGapY, placeGapY_inch);
                        
                        // Instead of using a redundant call to sendAllSettingsUpdate, create a more specific message
                        // about the changes that were made
                        char msgBuffer[200];
                        sprintf(msgBuffer, "Tray Size updated to W=%.2f, H=%.2f. Gap recalculated: X=%.3f, Y=%.3f", 
                               trayWidth_inch, trayHeight_inch, placeGapX_inch, placeGapY_inch);
                        
                        // Send settings update to the specific client that requested the change
                        sendAllSettingsUpdate(num, msgBuffer);
                        // Also broadcast to all other clients
                        if (num != 255) {
                            sendAllSettingsUpdate(255, msgBuffer);
                        }
                    } else {
                        Serial.printf("[DEBUG] Failed to parse SET_TRAY_SIZE command: %s\n", command.c_str());
                        webSocket.sendTXT(num, "{\"status\":\"Error\", \"message\":\"Invalid SET_TRAY_SIZE format.\"}");
                    }
                 } else if (command.startsWith("SET_PAINT_PATTERN_OFFSET ")) {
                    Serial.println("WebSocket: Received SET_PAINT_PATTERN_OFFSET command.");
                    if (isMoving || isHoming) { // Prevent changes while moving
                        webSocket.sendTXT(num, "{\"status\":\"Busy\",\"message\":\"Cannot set paint offsets while machine is busy.\"}");
                    } else {
                        float newX, newY;
                        int parsed = sscanf(command.c_str() + strlen("SET_PAINT_PATTERN_OFFSET "), "%f %f", &newX, &newY);
                        if (parsed == 2) {
                            paintPatternOffsetX_inch = newX;
                            paintPatternOffsetY_inch = newY;
                            // Save to Preferences
                            preferences.begin("machineCfg", false);
                            preferences.putFloat("paintPatOffX", paintPatternOffsetX_inch);
                            preferences.putFloat("paintPatOffY", paintPatternOffsetY_inch);
                            preferences.end();
                            Serial.printf("[DEBUG] Set Paint Pattern Offset to X: %.2f, Y: %.2f\n", paintPatternOffsetX_inch, paintPatternOffsetY_inch);
                            // Send confirmation with all settings
                            sendAllSettingsUpdate(num, "Paint Pattern Offset updated.");
                        } else {
                            webSocket.sendTXT(num, "{\"status\":\"Error\",\"message\":\"Invalid SET_PAINT_PATTERN_OFFSET format. Use: SET_PAINT_PATTERN_OFFSET X Y\"}");
                        }
                    }
                } else if (command.startsWith("SET_PAINT_GUN_OFFSET ")) {
                    Serial.println("WebSocket: Received SET_PAINT_GUN_OFFSET command.");
                     if (isMoving || isHoming) { // Prevent changes while moving
                        webSocket.sendTXT(num, "{\"status\":\"Busy\",\"message\":\"Cannot set paint offsets while machine is busy.\"}");
                    } else {
                        float newX, newY;
                        int parsed = sscanf(command.c_str() + strlen("SET_PAINT_GUN_OFFSET "), "%f %f", &newX, &newY);
                        if (parsed == 2) {
                            paintGunOffsetX_inch = newX;
                            paintGunOffsetY_inch = newY;
                            // Save to Preferences
                            preferences.begin("machineCfg", false);
                            preferences.putFloat("paintGunOffX", paintGunOffsetX_inch);
                            preferences.putFloat("paintGunOffY", paintGunOffsetY_inch);
                            preferences.end();
                            Serial.printf("[DEBUG] Set Paint Gun Offset to X: %.2f, Y: %.2f\n", paintGunOffsetX_inch, paintGunOffsetY_inch);
                            // Send confirmation with all settings
                            sendAllSettingsUpdate(num, "Paint Gun Offset updated.");
                        } else {
                            webSocket.sendTXT(num, "{\"status\":\"Error\",\"message\":\"Invalid SET_PAINT_GUN_OFFSET format. Use: SET_PAINT_GUN_OFFSET X Y\"}");
                        }
                    }
                } else if (command.startsWith("SET_PAINT_SIDE_SETTINGS ")) {
                    // Format: SET_PAINT_SIDE_SETTINGS sideIndex z pitch roll gun_orientation speed
                    Serial.println("WebSocket: Received SET_PAINT_SIDE_SETTINGS command.");
                    
                    // Parse command to extract parameters
                    String parts[6]; // Need 6 parts: sideIndex, z, pitch, roll, gunOrientation, speed
                    int partCount = 0;
                    int startPos = 23; // Skip "SET_PAINT_SIDE_SETTINGS "
                    
                    for (int i = 0; i < 6 && startPos < command.length(); i++) {
                        int spacePos = command.indexOf(' ', startPos);
                        if (spacePos == -1) {
                            // Last part
                            if (startPos < command.length()) {
                                parts[i] = command.substring(startPos);
                                partCount++;
                            }
                            break;
                        } else {
                            parts[i] = command.substring(startPos, spacePos);
                            startPos = spacePos + 1;
                            partCount++;
                        }
                    }
                    
                    if (partCount == 6) {
                        int sideIndex = parts[0].toInt();
                        float newZ = parts[1].toFloat();
                        int newPitch = parts[2].toInt();
                        int newRoll = parts[3].toInt();
                        int newGunOrientation = parts[4].toInt();
                        float newSpeed = parts[5].toFloat();
                        
                        // Validate parameters
                        if (sideIndex < 0 || sideIndex > 3) {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid side index\"}");
                            return;
                        }
                        
                        // Handle Z
                        if (newZ >= 0.0 && newZ <= 2.5) {
                            paintZHeight_inch[sideIndex] = newZ;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid Z height (must be between 0.0 and 2.5)\"}");
                            return;
                        }
                        
                        // Handle Pitch
                        if (newPitch >= 0 && newPitch <= 90) {
                            paintPitchAngle[sideIndex] = newPitch;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid pitch angle (must be between 0 and 90)\"}");
                            return;
                        }
                        
                        // Handle Roll
                        if (newRoll == 0 || newRoll == 90) {
                            paintRollAngle[sideIndex] = newRoll;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid roll angle (must be 0 or 90)\"}");
                            return;
                        }
                        
                        // Handle Gun Orientation
                        if (newGunOrientation == 0 || newGunOrientation == 90) {
                            paintGunOrientation[sideIndex] = newGunOrientation;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid gun orientation (must be 0 or 90)\"}");
                            return;
                        }
                        
                        // Handle Speed
                        if (newSpeed >= 5000.0 && newSpeed <= 25000.0) {
                            paintSpeed[sideIndex] = newSpeed;
                        } else {
                            webSocket.broadcastTXT("{\"status\":\"Error\", \"message\":\"Invalid speed (must be between 5000 and 25000)\"}");
                            return;
                        }
                        
                        // Save to preferences
                        preferences.begin("paintSettings", false);
                        String keyZ = "paintZ_" + String(sideIndex);
                        String keyP = "paintP_" + String(sideIndex);
                        String keyR = "paintR_" + String(sideIndex);
                        String keyGO = "paintGO_" + String(sideIndex);
                        String keyS = "paintS_" + String(sideIndex);
                        
                        preferences.putFloat(keyZ.c_str(), paintZHeight_inch[sideIndex]);
                        preferences.putInt(keyP.c_str(), paintPitchAngle[sideIndex]);
                        preferences.putInt(keyR.c_str(), paintRollAngle[sideIndex]);
                        preferences.putInt(keyGO.c_str(), paintGunOrientation[sideIndex]);
    Serial.printf("[DEBUG] Saved to preferences: gridCols=%d, gridRows=%d, gapX=%.3f, gapY=%.3f, trayWidth=%.2f, trayHeight=%.2f\n",
                 placeGridCols, placeGridRows, placeGapX_inch, placeGapY_inch, trayWidth_inch, trayHeight_inch);

    // Send update to UI
    String message = "Grid Columns/Rows updated. Gap calculated.";
    if (fitError) {
        message += " Warning: Items may not fit within tray dimensions!";
    }
    
    Serial.printf("[DEBUG] Sending update to UI with message: %s\n", message.c_str());
    sendAllSettingsUpdate(255, message); // Send to all clients
} 